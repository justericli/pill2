{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __rest, __values } from \"tslib\";\nimport { API } from '@aws-amplify/api';\nimport { ConsoleLogger as Logger, jitteredBackoff, NonRetryableError, retry, BackgroundProcessManager } from '@aws-amplify/core';\nimport Observable from 'zen-observable-ts';\nimport { DISCARD, isModelFieldType, isTargetNameAssociation, OpType, ProcessName } from '../../types';\nimport { extractTargetNamesFromSrc, USER, USER_AGENT_SUFFIX_DATASTORE, ID } from '../../util';\nimport { buildGraphQLOperation, createMutationInstanceFromModelOperation, getModelAuthModes, TransformerMutationType, getTokenForCustomAuth } from '../utils';\nimport { getMutationErrorType } from './errorMaps';\nvar MAX_ATTEMPTS = 10;\nvar logger = new Logger('DataStore');\nvar MutationProcessor = /** @class */function () {\n  function MutationProcessor(schema, storage, userClasses, outbox, modelInstanceCreator, MutationEvent, amplifyConfig, authModeStrategy, errorHandler, conflictHandler, amplifyContext) {\n    if (amplifyConfig === void 0) {\n      amplifyConfig = {};\n    }\n    this.schema = schema;\n    this.storage = storage;\n    this.userClasses = userClasses;\n    this.outbox = outbox;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.MutationEvent = MutationEvent;\n    this.amplifyConfig = amplifyConfig;\n    this.authModeStrategy = authModeStrategy;\n    this.errorHandler = errorHandler;\n    this.conflictHandler = conflictHandler;\n    this.amplifyContext = amplifyContext;\n    this.typeQuery = new WeakMap();\n    this.processing = false;\n    this.runningProcesses = new BackgroundProcessManager();\n    this.amplifyContext.API = this.amplifyContext.API || API;\n    this.generateQueries();\n  }\n  MutationProcessor.prototype.generateQueries = function () {\n    var _this = this;\n    Object.values(this.schema.namespaces).forEach(function (namespace) {\n      Object.values(namespace.models).filter(function (_a) {\n        var syncable = _a.syncable;\n        return syncable;\n      }).forEach(function (model) {\n        var _a = __read(buildGraphQLOperation(namespace, model, 'CREATE'), 1),\n          createMutation = _a[0];\n        var _b = __read(buildGraphQLOperation(namespace, model, 'UPDATE'), 1),\n          updateMutation = _b[0];\n        var _c = __read(buildGraphQLOperation(namespace, model, 'DELETE'), 1),\n          deleteMutation = _c[0];\n        _this.typeQuery.set(model, [createMutation, updateMutation, deleteMutation]);\n      });\n    });\n  };\n  MutationProcessor.prototype.isReady = function () {\n    return this.observer !== undefined;\n  };\n  MutationProcessor.prototype.start = function () {\n    var _this = this;\n    this.runningProcesses = new BackgroundProcessManager();\n    var observable = new Observable(function (observer) {\n      _this.observer = observer;\n      try {\n        _this.resume();\n      } catch (error) {\n        logger.error('mutations processor start error', error);\n        throw error;\n      }\n      return _this.runningProcesses.addCleaner(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          return __generator(this, function (_a) {\n            this.pause();\n            return [2 /*return*/];\n          });\n        });\n      });\n    });\n\n    return observable;\n  };\n  MutationProcessor.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.runningProcesses.close()];\n          case 1:\n            _a.sent();\n            return [4 /*yield*/, this.runningProcesses.open()];\n          case 2:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationProcessor.prototype.resume = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.runningProcesses.isOpen && this.runningProcesses.add(function (onTerminate) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var head, namespaceName, _loop_1, this_1, _a;\n                var _this = this;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      if (this.processing || !this.isReady() || !this.runningProcesses.isOpen) {\n                        return [2 /*return*/];\n                      }\n\n                      this.processing = true;\n                      namespaceName = USER;\n                      _loop_1 = function () {\n                        var model, operation, data, condition, modelConstructor, result, opName, modelDefinition, modelAuthModes, operationAuthModes_1, authModeAttempts_1, authModeRetry_1, error_1, record, hasMore;\n                        var _a;\n                        return __generator(this, function (_b) {\n                          switch (_b.label) {\n                            case 0:\n                              model = head.model, operation = head.operation, data = head.data, condition = head.condition;\n                              modelConstructor = this_1.userClasses[model];\n                              result = undefined;\n                              opName = undefined;\n                              modelDefinition = undefined;\n                              _b.label = 1;\n                            case 1:\n                              _b.trys.push([1, 4,, 5]);\n                              return [4 /*yield*/, getModelAuthModes({\n                                authModeStrategy: this_1.authModeStrategy,\n                                defaultAuthMode: this_1.amplifyConfig.aws_appsync_authenticationType,\n                                modelName: model,\n                                schema: this_1.schema\n                              })];\n                            case 2:\n                              modelAuthModes = _b.sent();\n                              operationAuthModes_1 = modelAuthModes[operation.toUpperCase()];\n                              authModeAttempts_1 = 0;\n                              authModeRetry_1 = function () {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  var response, error_2;\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        _a.trys.push([0, 2,, 4]);\n                                        logger.debug(\"Attempting mutation with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [4 /*yield*/, this.jitteredRetry(namespaceName, model, operation, data, condition, modelConstructor, this.MutationEvent, head, operationAuthModes_1[authModeAttempts_1], onTerminate)];\n                                      case 1:\n                                        response = _a.sent();\n                                        logger.debug(\"Mutation sent successfully with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [2 /*return*/, response];\n                                      case 2:\n                                        error_2 = _a.sent();\n                                        authModeAttempts_1++;\n                                        if (authModeAttempts_1 >= operationAuthModes_1.length) {\n                                          logger.debug(\"Mutation failed with authMode: \" + operationAuthModes_1[authModeAttempts_1 - 1]);\n                                          throw error_2;\n                                        }\n                                        logger.debug(\"Mutation failed with authMode: \" + operationAuthModes_1[authModeAttempts_1 - 1] + \". Retrying with authMode: \" + operationAuthModes_1[authModeAttempts_1]);\n                                        return [4 /*yield*/, authModeRetry_1()];\n                                      case 3:\n                                        return [2 /*return*/, _a.sent()];\n                                      case 4:\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              };\n\n                              return [4 /*yield*/, authModeRetry_1()];\n                            case 3:\n                              _a = __read.apply(void 0, [_b.sent(), 3]), result = _a[0], opName = _a[1], modelDefinition = _a[2];\n                              return [3 /*break*/, 5];\n                            case 4:\n                              error_1 = _b.sent();\n                              if (error_1.message === 'Offline' || error_1.message === 'RetryMutation') {\n                                return [2 /*return*/, \"continue\"];\n                              }\n                              return [3 /*break*/, 5];\n                            case 5:\n                              if (!(result === undefined)) return [3 /*break*/, 7];\n                              logger.debug('done retrying');\n                              return [4 /*yield*/, this_1.storage.runExclusive(function (storage) {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        return [4 /*yield*/, this.outbox.dequeue(storage)];\n                                      case 1:\n                                        _a.sent();\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              })];\n\n                            case 6:\n                              _b.sent();\n                              return [2 /*return*/, \"continue\"];\n                            case 7:\n                              record = result.data[opName];\n                              hasMore = false;\n                              return [4 /*yield*/, this_1.storage.runExclusive(function (storage) {\n                                return __awaiter(_this, void 0, void 0, function () {\n                                  return __generator(this, function (_a) {\n                                    switch (_a.label) {\n                                      case 0:\n                                        // using runExclusive to prevent possible race condition\n                                        // when another record gets enqueued between dequeue and peek\n                                        return [4 /*yield*/, this.outbox.dequeue(storage, record, operation)];\n                                      case 1:\n                                        // using runExclusive to prevent possible race condition\n                                        // when another record gets enqueued between dequeue and peek\n                                        _a.sent();\n                                        return [4 /*yield*/, this.outbox.peek(storage)];\n                                      case 2:\n                                        hasMore = _a.sent() !== undefined;\n                                        return [2 /*return*/];\n                                    }\n                                  });\n                                });\n                              })];\n\n                            case 8:\n                              _b.sent();\n                              this_1.observer.next({\n                                operation: operation,\n                                modelDefinition: modelDefinition,\n                                model: record,\n                                hasMore: hasMore\n                              });\n                              return [2 /*return*/];\n                          }\n                        });\n                      };\n\n                      this_1 = this;\n                      _b.label = 1;\n                    case 1:\n                      _a = this.processing && this.runningProcesses.isOpen;\n                      if (!_a) return [3 /*break*/, 3];\n                      return [4 /*yield*/, this.outbox.peek(this.storage)];\n                    case 2:\n                      _a = (head = _b.sent()) !== undefined;\n                      _b.label = 3;\n                    case 3:\n                      if (!_a) return [3 /*break*/, 5];\n                      return [5 /*yield**/, _loop_1()];\n                    case 4:\n                      _b.sent();\n                      return [3 /*break*/, 1];\n                    case 5:\n                      // pauses itself\n                      this.pause();\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }, 'mutation resume loop')];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  MutationProcessor.prototype.jitteredRetry = function (namespaceName, model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent, authMode, onTerminate) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, retry(function (model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var _a, query, variables, graphQLCondition, opName, modelDefinition, authToken, tryWith, attempt, opType, result, err_1, _b, error, _c, _d, code, retryWith, err_2, _e, _f, opName_1, query_1, authToken_1, serverData, namespace, updatedMutation;\n                var _g;\n                return __generator(this, function (_h) {\n                  switch (_h.label) {\n                    case 0:\n                      _a = __read(this.createQueryVariables(namespaceName, model, operation, data, condition), 5), query = _a[0], variables = _a[1], graphQLCondition = _a[2], opName = _a[3], modelDefinition = _a[4];\n                      return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                    case 1:\n                      authToken = _h.sent();\n                      tryWith = {\n                        query: query,\n                        variables: variables,\n                        authMode: authMode,\n                        authToken: authToken,\n                        userAgentSuffix: USER_AGENT_SUFFIX_DATASTORE\n                      };\n                      attempt = 0;\n                      opType = this.opTypeFromTransformerOperation(operation);\n                      _h.label = 2;\n                    case 2:\n                      _h.trys.push([2, 4,, 17]);\n                      return [4 /*yield*/, this.amplifyContext.API.graphql(tryWith)];\n                    case 3:\n                      result = _h.sent();\n                      // Use `as any` because TypeScript doesn't seem to like passing tuples\n                      // through generic params.\n                      return [2 /*return*/, [result, opName, modelDefinition]];\n                    case 4:\n                      err_1 = _h.sent();\n                      if (!(err_1.errors && err_1.errors.length > 0)) return [3 /*break*/, 15];\n                      _b = __read(err_1.errors, 1), error = _b[0];\n                      _c = error.originalError, _d = (_c === void 0 ? {} : _c).code, code = _d === void 0 ? null : _d;\n                      if (error.errorType === 'Unauthorized') {\n                        throw new NonRetryableError('Unauthorized');\n                      }\n                      if (error.message === 'Network Error' || code === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n                      ) {\n                        if (!this.processing) {\n                          throw new NonRetryableError('Offline');\n                        }\n                        // TODO: Check errors on different env (react-native or other browsers)\n                        throw new Error('Network Error');\n                      }\n                      if (!(error.errorType === 'ConflictUnhandled')) return [3 /*break*/, 13];\n                      // TODO: add on ConflictConditionalCheck error query last from server\n                      attempt++;\n                      retryWith = void 0;\n                      if (!(attempt > MAX_ATTEMPTS)) return [3 /*break*/, 5];\n                      retryWith = DISCARD;\n                      return [3 /*break*/, 8];\n                    case 5:\n                      _h.trys.push([5, 7,, 8]);\n                      return [4 /*yield*/, this.conflictHandler({\n                        modelConstructor: modelConstructor,\n                        localModel: this.modelInstanceCreator(modelConstructor, variables.input),\n                        remoteModel: this.modelInstanceCreator(modelConstructor, error.data),\n                        operation: opType,\n                        attempts: attempt\n                      })];\n                    case 6:\n                      retryWith = _h.sent();\n                      return [3 /*break*/, 8];\n                    case 7:\n                      err_2 = _h.sent();\n                      logger.warn('conflict trycatch', err_2);\n                      return [3 /*break*/, 17];\n                    case 8:\n                      if (!(retryWith === DISCARD)) return [3 /*break*/, 11];\n                      _e = __read(buildGraphQLOperation(this.schema.namespaces[namespaceName], modelDefinition, 'GET'), 1), _f = __read(_e[0], 3), opName_1 = _f[1], query_1 = _f[2];\n                      return [4 /*yield*/, getTokenForCustomAuth(authMode, this.amplifyConfig)];\n                    case 9:\n                      authToken_1 = _h.sent();\n                      return [4 /*yield*/, this.amplifyContext.API.graphql({\n                        query: query_1,\n                        variables: {\n                          id: variables.input.id\n                        },\n                        authMode: authMode,\n                        authToken: authToken_1,\n                        userAgentSuffix: USER_AGENT_SUFFIX_DATASTORE\n                      })];\n                    case 10:\n                      serverData = _h.sent();\n                      // onTerminate cancel graphql()\n                      return [2 /*return*/, [serverData, opName_1, modelDefinition]];\n                    case 11:\n                      namespace = this.schema.namespaces[namespaceName];\n                      updatedMutation = createMutationInstanceFromModelOperation(namespace.relationships, modelDefinition, opType, modelConstructor, retryWith, graphQLCondition, MutationEvent, this.modelInstanceCreator, mutationEvent.id);\n                      return [4 /*yield*/, this.storage.save(updatedMutation)];\n                    case 12:\n                      _h.sent();\n                      throw new NonRetryableError('RetryMutation');\n                    case 13:\n                      try {\n                        this.errorHandler({\n                          recoverySuggestion: 'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n                          localModel: variables.input,\n                          message: error.message,\n                          operation: operation,\n                          errorType: getMutationErrorType(error),\n                          errorInfo: error.errorInfo,\n                          process: ProcessName.mutate,\n                          cause: error,\n                          remoteModel: error.data ? this.modelInstanceCreator(modelConstructor, error.data) : null\n                        });\n                      } catch (err) {\n                        logger.warn('Mutation error handler failed with:', err);\n                      } finally {\n                        // Return empty tuple, dequeues the mutation\n                        return [2 /*return*/, error.data ? [{\n                          data: (_g = {}, _g[opName] = error.data, _g)\n                        }, opName, modelDefinition] : []];\n                      }\n                      _h.label = 14;\n                    case 14:\n                      return [3 /*break*/, 16];\n                    case 15:\n                      // Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n                      // These errors should not be retried.\n                      throw new NonRetryableError(err_1);\n                    case 16:\n                      return [3 /*break*/, 17];\n                    case 17:\n                      if (tryWith) return [3 /*break*/, 2];\n                      _h.label = 18;\n                    case 18:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }, [model, operation, data, condition, modelConstructor, MutationEvent, mutationEvent], safeJitteredBackoff, onTerminate)];\n          case 1:\n            return [2 /*return*/, _a.sent()];\n        }\n      });\n    });\n  };\n  MutationProcessor.prototype.createQueryVariables = function (namespaceName, model, operation, data, condition) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    var modelDefinition = this.schema.namespaces[namespaceName].models[model];\n    var primaryKey = this.schema.namespaces[namespaceName].keys[model].primaryKey;\n    var queriesTuples = this.typeQuery.get(modelDefinition);\n    var _d = __read(queriesTuples.find(function (_a) {\n        var _b = __read(_a, 1),\n          transformerMutationType = _b[0];\n        return transformerMutationType === operation;\n      }), 3),\n      opName = _d[1],\n      query = _d[2];\n    var _e = JSON.parse(data),\n      _version = _e._version,\n      parsedData = __rest(_e, [\"_version\"]);\n    // include all the fields that comprise a custom PK if one is specified\n    var deleteInput = {};\n    if (primaryKey === null || primaryKey === void 0 ? void 0 : primaryKey.length) {\n      try {\n        for (var primaryKey_1 = __values(primaryKey), primaryKey_1_1 = primaryKey_1.next(); !primaryKey_1_1.done; primaryKey_1_1 = primaryKey_1.next()) {\n          var pkField = primaryKey_1_1.value;\n          deleteInput[pkField] = parsedData[pkField];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (primaryKey_1_1 && !primaryKey_1_1.done && (_a = primaryKey_1.return)) _a.call(primaryKey_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    } else {\n      deleteInput[ID] = parsedData.id;\n    }\n    var mutationInput;\n    if (operation === TransformerMutationType.DELETE) {\n      // For DELETE mutations, only the key(s) are included in the input\n      mutationInput = deleteInput;\n    } else {\n      // Otherwise, we construct the mutation input with the following logic\n      mutationInput = {};\n      var modelFields = Object.values(modelDefinition.fields);\n      try {\n        for (var modelFields_1 = __values(modelFields), modelFields_1_1 = modelFields_1.next(); !modelFields_1_1.done; modelFields_1_1 = modelFields_1.next()) {\n          var _f = modelFields_1_1.value,\n            name_1 = _f.name,\n            type = _f.type,\n            association = _f.association;\n          // model fields should be stripped out from the input\n          if (isModelFieldType(type)) {\n            // except for belongs to relations - we need to replace them with the correct foreign key(s)\n            if (isTargetNameAssociation(association) && association.connectionType === 'BELONGS_TO') {\n              var targetNames = extractTargetNamesFromSrc(association);\n              if (targetNames) {\n                try {\n                  // instead of including the connected model itself, we add its key(s) to the mutation input\n                  for (var targetNames_1 = (e_3 = void 0, __values(targetNames)), targetNames_1_1 = targetNames_1.next(); !targetNames_1_1.done; targetNames_1_1 = targetNames_1.next()) {\n                    var targetName = targetNames_1_1.value;\n                    mutationInput[targetName] = parsedData[targetName];\n                  }\n                } catch (e_3_1) {\n                  e_3 = {\n                    error: e_3_1\n                  };\n                } finally {\n                  try {\n                    if (targetNames_1_1 && !targetNames_1_1.done && (_c = targetNames_1.return)) _c.call(targetNames_1);\n                  } finally {\n                    if (e_3) throw e_3.error;\n                  }\n                }\n              }\n            }\n            continue;\n          }\n          // scalar fields / non-model types\n          if (operation === TransformerMutationType.UPDATE) {\n            if (!parsedData.hasOwnProperty(name_1)) {\n              // for update mutations - strip out a field if it's unchanged\n              continue;\n            }\n          }\n          // all other fields are added to the input object\n          mutationInput[name_1] = parsedData[name_1];\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (modelFields_1_1 && !modelFields_1_1.done && (_b = modelFields_1.return)) _b.call(modelFields_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    // Build mutation variables input object\n    var input = __assign(__assign({}, mutationInput), {\n      _version: _version\n    });\n    var graphQLCondition = JSON.parse(condition);\n    var variables = __assign({\n      input: input\n    }, operation === TransformerMutationType.CREATE ? {} : {\n      condition: Object.keys(graphQLCondition).length > 0 ? graphQLCondition : null\n    });\n    return [query, variables, graphQLCondition, opName, modelDefinition];\n  };\n  MutationProcessor.prototype.opTypeFromTransformerOperation = function (operation) {\n    switch (operation) {\n      case TransformerMutationType.CREATE:\n        return OpType.INSERT;\n      case TransformerMutationType.DELETE:\n        return OpType.DELETE;\n      case TransformerMutationType.UPDATE:\n        return OpType.UPDATE;\n      case TransformerMutationType.GET:\n        // Intentionally blank\n        break;\n      default:\n        throw new Error(\"Invalid operation \" + operation);\n    }\n    // because it makes TS happy ...\n    return undefined;\n  };\n  MutationProcessor.prototype.pause = function () {\n    this.processing = false;\n  };\n  return MutationProcessor;\n}();\nvar MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nvar originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport var safeJitteredBackoff = function (attempt, _args, error) {\n  var attemptResult = originalJitteredBackoff(attempt);\n  // If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n  if (attemptResult === false && (error === null || error === void 0 ? void 0 : error.message) === 'Network Error') {\n    return MAX_RETRY_DELAY_MS;\n  }\n  return attemptResult;\n};\nexport { MutationProcessor };","map":{"version":3,"names":["API","ConsoleLogger","Logger","jitteredBackoff","NonRetryableError","retry","BackgroundProcessManager","Observable","DISCARD","isModelFieldType","isTargetNameAssociation","OpType","ProcessName","extractTargetNamesFromSrc","USER","USER_AGENT_SUFFIX_DATASTORE","ID","buildGraphQLOperation","createMutationInstanceFromModelOperation","getModelAuthModes","TransformerMutationType","getTokenForCustomAuth","getMutationErrorType","MAX_ATTEMPTS","logger","MutationProcessor","schema","storage","userClasses","outbox","modelInstanceCreator","MutationEvent","amplifyConfig","authModeStrategy","errorHandler","conflictHandler","amplifyContext","typeQuery","WeakMap","processing","runningProcesses","generateQueries","prototype","_this","Object","values","namespaces","forEach","namespace","models","filter","_a","syncable","model","__read","createMutation","_b","updateMutation","_c","deleteMutation","set","isReady","observer","undefined","start","observable","resume","error","addCleaner","__awaiter","pause","stop","close","sent","open","isOpen","add","onTerminate","namespaceName","head","operation","data","condition","modelConstructor","this_1","result","opName","modelDefinition","defaultAuthMode","aws_appsync_authenticationType","modelName","modelAuthModes","operationAuthModes_1","toUpperCase","authModeAttempts_1","authModeRetry_1","debug","jitteredRetry","response","length","error_2","apply","error_1","message","runExclusive","dequeue","record","hasMore","peek","next","mutationEvent","authMode","createQueryVariables","query","variables","graphQLCondition","authToken","_h","tryWith","userAgentSuffix","attempt","opType","opTypeFromTransformerOperation","graphql","err_1","errors","originalError","_d","code","errorType","Error","retryWith","localModel","input","remoteModel","attempts","warn","err_2","_e","_f","opName_1","query_1","authToken_1","id","serverData","updatedMutation","relationships","save","recoverySuggestion","errorInfo","process","mutate","cause","err","_g","safeJitteredBackoff","primaryKey","keys","queriesTuples","get","find","JSON","parse","_version","parsedData","__rest","deleteInput","primaryKey_1","__values","primaryKey_1_1","done","pkField","value","mutationInput","DELETE","modelFields","fields","modelFields_1","modelFields_1_1","name_1","name","type","association","connectionType","targetNames","targetNames_1","e_3","targetNames_1_1","targetName","UPDATE","hasOwnProperty","__assign","CREATE","INSERT","GET","MAX_RETRY_DELAY_MS","originalJitteredBackoff","_args","attemptResult"],"sources":["/Users/ericli/node_modules/@aws-amplify/datastore/src/sync/processors/mutation.ts"],"sourcesContent":["import { API, GraphQLResult, GRAPHQL_AUTH_MODE } from '@aws-amplify/api';\nimport {\n\tConsoleLogger as Logger,\n\tjitteredBackoff,\n\tNonRetryableError,\n\tretry,\n\tBackgroundProcessManager,\n} from '@aws-amplify/core';\nimport Observable, { ZenObservable } from 'zen-observable-ts';\nimport { MutationEvent } from '../';\nimport { ModelInstanceCreator } from '../../datastore/datastore';\nimport { ExclusiveStorage as Storage } from '../../storage/storage';\nimport {\n\tAuthModeStrategy,\n\tConflictHandler,\n\tDISCARD,\n\tErrorHandler,\n\tGraphQLCondition,\n\tInternalSchema,\n\tisModelFieldType,\n\tisTargetNameAssociation,\n\tModelInstanceMetadata,\n\tOpType,\n\tPersistentModel,\n\tPersistentModelConstructor,\n\tSchemaModel,\n\tTypeConstructorMap,\n\tProcessName,\n\tAmplifyContext,\n} from '../../types';\nimport {\n\textractTargetNamesFromSrc,\n\tUSER,\n\tUSER_AGENT_SUFFIX_DATASTORE,\n\tID,\n} from '../../util';\nimport { MutationEventOutbox } from '../outbox';\nimport {\n\tbuildGraphQLOperation,\n\tcreateMutationInstanceFromModelOperation,\n\tgetModelAuthModes,\n\tTransformerMutationType,\n\tgetTokenForCustomAuth,\n} from '../utils';\nimport { getMutationErrorType } from './errorMaps';\n\nconst MAX_ATTEMPTS = 10;\n\nconst logger = new Logger('DataStore');\n\ntype MutationProcessorEvent = {\n\toperation: TransformerMutationType;\n\tmodelDefinition: SchemaModel;\n\tmodel: PersistentModel;\n\thasMore: boolean;\n};\n\nclass MutationProcessor {\n\tprivate observer!: ZenObservable.Observer<MutationProcessorEvent>;\n\tprivate readonly typeQuery = new WeakMap<\n\t\tSchemaModel,\n\t\t[TransformerMutationType, string, string][]\n\t>();\n\tprivate processing: boolean = false;\n\n\tprivate runningProcesses = new BackgroundProcessManager();\n\n\tconstructor(\n\t\tprivate readonly schema: InternalSchema,\n\t\tprivate readonly storage: Storage,\n\t\tprivate readonly userClasses: TypeConstructorMap,\n\t\tprivate readonly outbox: MutationEventOutbox,\n\t\tprivate readonly modelInstanceCreator: ModelInstanceCreator,\n\t\tprivate readonly MutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tprivate readonly amplifyConfig: Record<string, any> = {},\n\t\tprivate readonly authModeStrategy: AuthModeStrategy,\n\t\tprivate readonly errorHandler: ErrorHandler,\n\t\tprivate readonly conflictHandler: ConflictHandler,\n\t\tprivate readonly amplifyContext: AmplifyContext\n\t) {\n\t\tthis.amplifyContext.API = this.amplifyContext.API || API;\n\t\tthis.generateQueries();\n\t}\n\n\tprivate generateQueries() {\n\t\tObject.values(this.schema.namespaces).forEach(namespace => {\n\t\t\tObject.values(namespace.models)\n\t\t\t\t.filter(({ syncable }) => syncable)\n\t\t\t\t.forEach(model => {\n\t\t\t\t\tconst [createMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'CREATE'\n\t\t\t\t\t);\n\t\t\t\t\tconst [updateMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'UPDATE'\n\t\t\t\t\t);\n\t\t\t\t\tconst [deleteMutation] = buildGraphQLOperation(\n\t\t\t\t\t\tnamespace,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t'DELETE'\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.typeQuery.set(model, [\n\t\t\t\t\t\tcreateMutation,\n\t\t\t\t\t\tupdateMutation,\n\t\t\t\t\t\tdeleteMutation,\n\t\t\t\t\t]);\n\t\t\t\t});\n\t\t});\n\t}\n\n\tprivate isReady() {\n\t\treturn this.observer !== undefined;\n\t}\n\n\tpublic start(): Observable<MutationProcessorEvent> {\n\t\tthis.runningProcesses = new BackgroundProcessManager();\n\n\t\tconst observable = new Observable<MutationProcessorEvent>(observer => {\n\t\t\tthis.observer = observer;\n\n\t\t\ttry {\n\t\t\t\tthis.resume();\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error('mutations processor start error', error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\treturn this.runningProcesses.addCleaner(async () => {\n\t\t\t\tthis.pause();\n\t\t\t});\n\t\t});\n\n\t\treturn observable;\n\t}\n\n\tpublic async stop() {\n\t\tawait this.runningProcesses.close();\n\t\tawait this.runningProcesses.open();\n\t}\n\n\tpublic async resume(): Promise<void> {\n\t\tawait (this.runningProcesses.isOpen &&\n\t\t\tthis.runningProcesses.add(async onTerminate => {\n\t\t\t\tif (\n\t\t\t\t\tthis.processing ||\n\t\t\t\t\t!this.isReady() ||\n\t\t\t\t\t!this.runningProcesses.isOpen\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.processing = true;\n\t\t\t\tlet head: MutationEvent;\n\t\t\t\tconst namespaceName = USER;\n\n\t\t\t\t// start to drain outbox\n\t\t\t\twhile (\n\t\t\t\t\tthis.processing &&\n\t\t\t\t\tthis.runningProcesses.isOpen &&\n\t\t\t\t\t(head = await this.outbox.peek(this.storage)) !== undefined\n\t\t\t\t) {\n\t\t\t\t\tconst { model, operation, data, condition } = head;\n\t\t\t\t\tconst modelConstructor = this.userClasses[\n\t\t\t\t\t\tmodel\n\t\t\t\t\t] as PersistentModelConstructor<MutationEvent>;\n\t\t\t\t\tlet result: GraphQLResult<Record<string, PersistentModel>> =\n\t\t\t\t\t\tundefined!;\n\t\t\t\t\tlet opName: string = undefined!;\n\t\t\t\t\tlet modelDefinition: SchemaModel = undefined!;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst modelAuthModes = await getModelAuthModes({\n\t\t\t\t\t\t\tauthModeStrategy: this.authModeStrategy,\n\t\t\t\t\t\t\tdefaultAuthMode:\n\t\t\t\t\t\t\t\tthis.amplifyConfig.aws_appsync_authenticationType,\n\t\t\t\t\t\t\tmodelName: model,\n\t\t\t\t\t\t\tschema: this.schema,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst operationAuthModes = modelAuthModes[operation.toUpperCase()];\n\n\t\t\t\t\t\tlet authModeAttempts = 0;\n\t\t\t\t\t\tconst authModeRetry = async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Attempting mutation with authMode: ${operationAuthModes[authModeAttempts]}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst response = await this.jitteredRetry(\n\t\t\t\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tcondition,\n\t\t\t\t\t\t\t\t\tmodelConstructor as any,\n\t\t\t\t\t\t\t\t\tthis.MutationEvent,\n\t\t\t\t\t\t\t\t\thead,\n\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts],\n\t\t\t\t\t\t\t\t\tonTerminate\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Mutation sent successfully with authMode: ${operationAuthModes[authModeAttempts]}`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tauthModeAttempts++;\n\t\t\t\t\t\t\t\tif (authModeAttempts >= operationAuthModes.length) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t`Mutation failed with authMode: ${\n\t\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts - 1]\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t`Mutation failed with authMode: ${\n\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts - 1]\n\t\t\t\t\t\t\t\t\t}. Retrying with authMode: ${\n\t\t\t\t\t\t\t\t\t\toperationAuthModes[authModeAttempts]\n\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn await authModeRetry();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t[result, opName, modelDefinition] = await authModeRetry();\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terror.message === 'Offline' ||\n\t\t\t\t\t\t\terror.message === 'RetryMutation'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tlogger.debug('done retrying');\n\t\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t\tawait this.outbox.dequeue(storage);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst record = result.data![opName!];\n\t\t\t\t\tlet hasMore = false;\n\n\t\t\t\t\tawait this.storage.runExclusive(async storage => {\n\t\t\t\t\t\t// using runExclusive to prevent possible race condition\n\t\t\t\t\t\t// when another record gets enqueued between dequeue and peek\n\t\t\t\t\t\tawait this.outbox.dequeue(storage, record, operation);\n\t\t\t\t\t\thasMore = (await this.outbox.peek(storage)) !== undefined;\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.observer.next!({\n\t\t\t\t\t\toperation,\n\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\tmodel: record,\n\t\t\t\t\t\thasMore,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// pauses itself\n\t\t\t\tthis.pause();\n\t\t\t}, 'mutation resume loop'));\n\t}\n\n\tprivate async jitteredRetry(\n\t\tnamespaceName: string,\n\t\tmodel: string,\n\t\toperation: TransformerMutationType,\n\t\tdata: string,\n\t\tcondition: string,\n\t\tmodelConstructor: PersistentModelConstructor<PersistentModel>,\n\t\tMutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\tmutationEvent: MutationEvent,\n\t\tauthMode: GRAPHQL_AUTH_MODE,\n\t\tonTerminate: Promise<void>\n\t): Promise<\n\t\t[GraphQLResult<Record<string, PersistentModel>>, string, SchemaModel]\n\t> {\n\t\treturn await retry(\n\t\t\tasync (\n\t\t\t\tmodel: string,\n\t\t\t\toperation: TransformerMutationType,\n\t\t\t\tdata: string,\n\t\t\t\tcondition: string,\n\t\t\t\tmodelConstructor: PersistentModelConstructor<PersistentModel>,\n\t\t\t\tMutationEvent: PersistentModelConstructor<MutationEvent>,\n\t\t\t\tmutationEvent: MutationEvent\n\t\t\t) => {\n\t\t\t\tconst [query, variables, graphQLCondition, opName, modelDefinition] =\n\t\t\t\t\tthis.createQueryVariables(\n\t\t\t\t\t\tnamespaceName,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\toperation,\n\t\t\t\t\t\tdata,\n\t\t\t\t\t\tcondition\n\t\t\t\t\t);\n\n\t\t\t\tconst authToken = await getTokenForCustomAuth(\n\t\t\t\t\tauthMode,\n\t\t\t\t\tthis.amplifyConfig\n\t\t\t\t);\n\n\t\t\t\tconst tryWith = {\n\t\t\t\t\tquery,\n\t\t\t\t\tvariables,\n\t\t\t\t\tauthMode,\n\t\t\t\t\tauthToken,\n\t\t\t\t\tuserAgentSuffix: USER_AGENT_SUFFIX_DATASTORE,\n\t\t\t\t};\n\t\t\t\tlet attempt = 0;\n\n\t\t\t\tconst opType = this.opTypeFromTransformerOperation(operation);\n\n\t\t\t\tdo {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst result = <GraphQLResult<Record<string, PersistentModel>>>(\n\t\t\t\t\t\t\tawait this.amplifyContext.API.graphql(tryWith)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Use `as any` because TypeScript doesn't seem to like passing tuples\n\t\t\t\t\t\t// through generic params.\n\t\t\t\t\t\treturn [result, opName, modelDefinition] as any;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tif (err.errors && err.errors.length > 0) {\n\t\t\t\t\t\t\tconst [error] = err.errors;\n\t\t\t\t\t\t\tconst { originalError: { code = null } = {} } = error;\n\n\t\t\t\t\t\t\tif (error.errorType === 'Unauthorized') {\n\t\t\t\t\t\t\t\tthrow new NonRetryableError('Unauthorized');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\terror.message === 'Network Error' ||\n\t\t\t\t\t\t\t\tcode === 'ECONNABORTED' // refers to axios timeout error caused by device's bad network condition\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (!this.processing) {\n\t\t\t\t\t\t\t\t\tthrow new NonRetryableError('Offline');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TODO: Check errors on different env (react-native or other browsers)\n\t\t\t\t\t\t\t\tthrow new Error('Network Error');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (error.errorType === 'ConflictUnhandled') {\n\t\t\t\t\t\t\t\t// TODO: add on ConflictConditionalCheck error query last from server\n\t\t\t\t\t\t\t\tattempt++;\n\t\t\t\t\t\t\t\tlet retryWith: PersistentModel | typeof DISCARD;\n\n\t\t\t\t\t\t\t\tif (attempt > MAX_ATTEMPTS) {\n\t\t\t\t\t\t\t\t\tretryWith = DISCARD;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tretryWith = await this.conflictHandler!({\n\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\tlocalModel: this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\tvariables.input\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\tremoteModel: this.modelInstanceCreator(\n\t\t\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\t\t\terror.data\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\toperation: opType,\n\t\t\t\t\t\t\t\t\t\t\tattempts: attempt,\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tlogger.warn('conflict trycatch', err);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (retryWith === DISCARD) {\n\t\t\t\t\t\t\t\t\t// Query latest from server and notify merger\n\n\t\t\t\t\t\t\t\t\tconst [[, opName, query]] = buildGraphQLOperation(\n\t\t\t\t\t\t\t\t\t\tthis.schema.namespaces[namespaceName],\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t'GET'\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst authToken = await getTokenForCustomAuth(\n\t\t\t\t\t\t\t\t\t\tauthMode,\n\t\t\t\t\t\t\t\t\t\tthis.amplifyConfig\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst serverData = <\n\t\t\t\t\t\t\t\t\t\tGraphQLResult<Record<string, PersistentModel>>\n\t\t\t\t\t\t\t\t\t>await this.amplifyContext.API.graphql({\n\t\t\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\t\t\tvariables: { id: variables.input.id },\n\t\t\t\t\t\t\t\t\t\tauthMode,\n\t\t\t\t\t\t\t\t\t\tauthToken,\n\t\t\t\t\t\t\t\t\t\tuserAgentSuffix: USER_AGENT_SUFFIX_DATASTORE,\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t// onTerminate cancel graphql()\n\n\t\t\t\t\t\t\t\t\treturn [serverData, opName, modelDefinition];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst namespace = this.schema.namespaces[namespaceName];\n\n\t\t\t\t\t\t\t\t// convert retry with to tryWith\n\t\t\t\t\t\t\t\tconst updatedMutation =\n\t\t\t\t\t\t\t\t\tcreateMutationInstanceFromModelOperation(\n\t\t\t\t\t\t\t\t\t\tnamespace.relationships!,\n\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\topType,\n\t\t\t\t\t\t\t\t\t\tmodelConstructor,\n\t\t\t\t\t\t\t\t\t\tretryWith,\n\t\t\t\t\t\t\t\t\t\tgraphQLCondition,\n\t\t\t\t\t\t\t\t\t\tMutationEvent,\n\t\t\t\t\t\t\t\t\t\tthis.modelInstanceCreator,\n\t\t\t\t\t\t\t\t\t\tmutationEvent.id\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tawait this.storage.save(updatedMutation);\n\n\t\t\t\t\t\t\t\tthrow new NonRetryableError('RetryMutation');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tthis.errorHandler({\n\t\t\t\t\t\t\t\t\t\trecoverySuggestion:\n\t\t\t\t\t\t\t\t\t\t\t'Ensure app code is up to date, auth directives exist and are correct on each model, and that server-side data has not been invalidated by a schema change. If the problem persists, search for or create an issue: https://github.com/aws-amplify/amplify-js/issues',\n\t\t\t\t\t\t\t\t\t\tlocalModel: variables.input,\n\t\t\t\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\t\t\t\toperation,\n\t\t\t\t\t\t\t\t\t\terrorType: getMutationErrorType(error),\n\t\t\t\t\t\t\t\t\t\terrorInfo: error.errorInfo,\n\t\t\t\t\t\t\t\t\t\tprocess: ProcessName.mutate,\n\t\t\t\t\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\t\t\t\t\tremoteModel: error.data\n\t\t\t\t\t\t\t\t\t\t\t? this.modelInstanceCreator(modelConstructor, error.data)\n\t\t\t\t\t\t\t\t\t\t\t: null!,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\tlogger.warn('Mutation error handler failed with:', err);\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// Return empty tuple, dequeues the mutation\n\t\t\t\t\t\t\t\t\treturn error.data\n\t\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t\t{ data: { [opName]: error.data } },\n\t\t\t\t\t\t\t\t\t\t\t\topName,\n\t\t\t\t\t\t\t\t\t\t\t\tmodelDefinition,\n\t\t\t\t\t\t\t\t\t\t  ]\n\t\t\t\t\t\t\t\t\t\t: [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Catch-all for client-side errors that don't come back in the `GraphQLError` format.\n\t\t\t\t\t\t\t// These errors should not be retried.\n\t\t\t\t\t\t\tthrow new NonRetryableError(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (tryWith);\n\t\t\t},\n\t\t\t[\n\t\t\t\tmodel,\n\t\t\t\toperation,\n\t\t\t\tdata,\n\t\t\t\tcondition,\n\t\t\t\tmodelConstructor,\n\t\t\t\tMutationEvent,\n\t\t\t\tmutationEvent,\n\t\t\t],\n\t\t\tsafeJitteredBackoff,\n\t\t\tonTerminate\n\t\t);\n\t}\n\n\tprivate createQueryVariables(\n\t\tnamespaceName: string,\n\t\tmodel: string,\n\t\toperation: TransformerMutationType,\n\t\tdata: string,\n\t\tcondition: string\n\t): [string, Record<string, any>, GraphQLCondition, string, SchemaModel] {\n\t\tconst modelDefinition = this.schema.namespaces[namespaceName].models[model];\n\t\tconst { primaryKey } = this.schema.namespaces[namespaceName].keys![model];\n\n\t\tconst queriesTuples = this.typeQuery.get(modelDefinition);\n\n\t\tconst [, opName, query] = queriesTuples!.find(\n\t\t\t([transformerMutationType]) => transformerMutationType === operation\n\t\t)!;\n\n\t\tconst { _version, ...parsedData } = <ModelInstanceMetadata>JSON.parse(data);\n\n\t\t// include all the fields that comprise a custom PK if one is specified\n\t\tconst deleteInput = {};\n\t\tif (primaryKey?.length) {\n\t\t\tfor (const pkField of primaryKey) {\n\t\t\t\tdeleteInput[pkField] = parsedData[pkField];\n\t\t\t}\n\t\t} else {\n\t\t\tdeleteInput[ID] = (<any>parsedData).id;\n\t\t}\n\n\t\tlet mutationInput;\n\n\t\tif (operation === TransformerMutationType.DELETE) {\n\t\t\t// For DELETE mutations, only the key(s) are included in the input\n\t\t\tmutationInput = <ModelInstanceMetadata>deleteInput;\n\t\t} else {\n\t\t\t// Otherwise, we construct the mutation input with the following logic\n\t\t\tmutationInput = {};\n\t\t\tconst modelFields = Object.values(modelDefinition.fields);\n\n\t\t\tfor (const { name, type, association } of modelFields) {\n\t\t\t\t// model fields should be stripped out from the input\n\t\t\t\tif (isModelFieldType(type)) {\n\t\t\t\t\t// except for belongs to relations - we need to replace them with the correct foreign key(s)\n\t\t\t\t\tif (\n\t\t\t\t\t\tisTargetNameAssociation(association) &&\n\t\t\t\t\t\tassociation.connectionType === 'BELONGS_TO'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst targetNames: string[] | undefined =\n\t\t\t\t\t\t\textractTargetNamesFromSrc(association);\n\n\t\t\t\t\t\tif (targetNames) {\n\t\t\t\t\t\t\t// instead of including the connected model itself, we add its key(s) to the mutation input\n\t\t\t\t\t\t\tfor (const targetName of targetNames) {\n\t\t\t\t\t\t\t\tmutationInput[targetName] = parsedData[targetName];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// scalar fields / non-model types\n\n\t\t\t\tif (operation === TransformerMutationType.UPDATE) {\n\t\t\t\t\tif (!parsedData.hasOwnProperty(name)) {\n\t\t\t\t\t\t// for update mutations - strip out a field if it's unchanged\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// all other fields are added to the input object\n\t\t\t\tmutationInput[name] = parsedData[name];\n\t\t\t}\n\t\t}\n\n\t\t// Build mutation variables input object\n\t\tconst input: ModelInstanceMetadata = {\n\t\t\t...mutationInput,\n\t\t\t_version,\n\t\t};\n\n\t\tconst graphQLCondition = <GraphQLCondition>JSON.parse(condition);\n\n\t\tconst variables = {\n\t\t\tinput,\n\t\t\t...(operation === TransformerMutationType.CREATE\n\t\t\t\t? {}\n\t\t\t\t: {\n\t\t\t\t\t\tcondition:\n\t\t\t\t\t\t\tObject.keys(graphQLCondition).length > 0\n\t\t\t\t\t\t\t\t? graphQLCondition\n\t\t\t\t\t\t\t\t: null,\n\t\t\t\t  }),\n\t\t};\n\t\treturn [query, variables, graphQLCondition, opName, modelDefinition];\n\t}\n\n\tprivate opTypeFromTransformerOperation(\n\t\toperation: TransformerMutationType\n\t): OpType {\n\t\tswitch (operation) {\n\t\t\tcase TransformerMutationType.CREATE:\n\t\t\t\treturn OpType.INSERT;\n\t\t\tcase TransformerMutationType.DELETE:\n\t\t\t\treturn OpType.DELETE;\n\t\t\tcase TransformerMutationType.UPDATE:\n\t\t\t\treturn OpType.UPDATE;\n\t\t\tcase TransformerMutationType.GET: // Intentionally blank\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid operation ${operation}`);\n\t\t}\n\n\t\t// because it makes TS happy ...\n\t\treturn undefined!;\n\t}\n\n\tpublic pause() {\n\t\tthis.processing = false;\n\t}\n}\n\nconst MAX_RETRY_DELAY_MS = 5 * 60 * 1000;\nconst originalJitteredBackoff = jitteredBackoff(MAX_RETRY_DELAY_MS);\n\n/**\n * @private\n * Internal use of Amplify only.\n *\n * Wraps the jittered backoff calculation to retry Network Errors indefinitely.\n * Backs off according to original jittered retry logic until the original retry\n * logic hits its max. After this occurs, if the error is a Network Error, we\n * ignore the attempt count and return MAX_RETRY_DELAY_MS to retry forever (until\n * the request succeeds).\n *\n * @param attempt ignored\n * @param _args ignored\n * @param error tested to see if `.message` is 'Network Error'\n * @returns number | false :\n */\nexport const safeJitteredBackoff: typeof originalJitteredBackoff = (\n\tattempt,\n\t_args,\n\terror\n) => {\n\tconst attemptResult = originalJitteredBackoff(attempt);\n\n\t// If this is the last attempt and it is a network error, we retry indefinitively every 5 minutes\n\tif (attemptResult === false && error?.message === 'Network Error') {\n\t\treturn MAX_RETRY_DELAY_MS;\n\t}\n\n\treturn attemptResult;\n};\n\nexport { MutationProcessor };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}