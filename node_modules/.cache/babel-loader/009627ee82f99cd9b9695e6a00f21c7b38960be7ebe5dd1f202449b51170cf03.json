{"ast":null,"code":"import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS } from \"./constants\";\nimport { getDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n  constructor(maxAttempts) {\n    this.maxAttempts = maxAttempts;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);\n    this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts;\n  }\n  async acquireInitialRetryToken(retryTokenScope) {\n    return this.retryToken;\n  }\n  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n    const maxAttempts = await this.getMaxAttempts();\n    if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {\n      tokenToRenew.getRetryTokenCount(errorInfo);\n      return tokenToRenew;\n    }\n    throw new Error(\"No retry token available\");\n  }\n  recordSuccess(token) {\n    this.retryToken.releaseRetryTokens(token.getLastRetryCost());\n  }\n  async getMaxAttempts() {\n    let maxAttempts;\n    try {\n      return await this.maxAttemptsProvider();\n    } catch (error) {\n      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n      return DEFAULT_MAX_ATTEMPTS;\n    }\n  }\n  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n    const attempts = tokenToRenew.getRetryCount();\n    return attempts < maxAttempts && tokenToRenew.hasRetryTokens(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);\n  }\n  isRetryableError(errorType) {\n    return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n  }\n}","map":{"version":3,"names":["DEFAULT_MAX_ATTEMPTS","RETRY_MODES","DEFAULT_RETRY_DELAY_BASE","INITIAL_RETRY_TOKENS","getDefaultRetryToken","StandardRetryStrategy","constructor","maxAttempts","mode","STANDARD","retryToken","maxAttemptsProvider","acquireInitialRetryToken","retryTokenScope","refreshRetryTokenForRetry","tokenToRenew","errorInfo","getMaxAttempts","shouldRetry","getRetryTokenCount","Error","recordSuccess","token","releaseRetryTokens","getLastRetryCost","error","console","warn","attempts","getRetryCount","hasRetryTokens","errorType","isRetryableError"],"sources":["/Users/ericli/Desktop/pill2/node_modules/@aws-sdk/util-retry/dist-es/StandardRetryStrategy.js"],"sourcesContent":["import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS } from \"./constants\";\nimport { getDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n    constructor(maxAttempts) {\n        this.maxAttempts = maxAttempts;\n        this.mode = RETRY_MODES.STANDARD;\n        this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);\n        this.maxAttemptsProvider = typeof maxAttempts === \"function\" ? maxAttempts : async () => maxAttempts;\n    }\n    async acquireInitialRetryToken(retryTokenScope) {\n        return this.retryToken;\n    }\n    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n        const maxAttempts = await this.getMaxAttempts();\n        if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {\n            tokenToRenew.getRetryTokenCount(errorInfo);\n            return tokenToRenew;\n        }\n        throw new Error(\"No retry token available\");\n    }\n    recordSuccess(token) {\n        this.retryToken.releaseRetryTokens(token.getLastRetryCost());\n    }\n    async getMaxAttempts() {\n        let maxAttempts;\n        try {\n            return await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n            return DEFAULT_MAX_ATTEMPTS;\n        }\n    }\n    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n        const attempts = tokenToRenew.getRetryCount();\n        return (attempts < maxAttempts &&\n            tokenToRenew.hasRetryTokens(errorInfo.errorType) &&\n            this.isRetryableError(errorInfo.errorType));\n    }\n    isRetryableError(errorType) {\n        return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n    }\n}\n"],"mappings":"AAAA,SAASA,oBAAoB,EAAEC,WAAW,QAAQ,UAAU;AAC5D,SAASC,wBAAwB,EAAEC,oBAAoB,QAAQ,aAAa;AAC5E,SAASC,oBAAoB,QAAQ,qBAAqB;AAC1D,OAAO,MAAMC,qBAAqB,CAAC;EAC/BC,WAAWA,CAACC,WAAW,EAAE;IACrB,IAAI,CAACA,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,IAAI,GAAGP,WAAW,CAACQ,QAAQ;IAChC,IAAI,CAACC,UAAU,GAAGN,oBAAoB,CAACD,oBAAoB,EAAED,wBAAwB,CAAC;IACtF,IAAI,CAACS,mBAAmB,GAAG,OAAOJ,WAAW,KAAK,UAAU,GAAGA,WAAW,GAAG,YAAYA,WAAW;EACxG;EACA,MAAMK,wBAAwBA,CAACC,eAAe,EAAE;IAC5C,OAAO,IAAI,CAACH,UAAU;EAC1B;EACA,MAAMI,yBAAyBA,CAACC,YAAY,EAAEC,SAAS,EAAE;IACrD,MAAMT,WAAW,GAAG,MAAM,IAAI,CAACU,cAAc,EAAE;IAC/C,IAAI,IAAI,CAACC,WAAW,CAACH,YAAY,EAAEC,SAAS,EAAET,WAAW,CAAC,EAAE;MACxDQ,YAAY,CAACI,kBAAkB,CAACH,SAAS,CAAC;MAC1C,OAAOD,YAAY;IACvB;IACA,MAAM,IAAIK,KAAK,CAAC,0BAA0B,CAAC;EAC/C;EACAC,aAAaA,CAACC,KAAK,EAAE;IACjB,IAAI,CAACZ,UAAU,CAACa,kBAAkB,CAACD,KAAK,CAACE,gBAAgB,EAAE,CAAC;EAChE;EACA,MAAMP,cAAcA,CAAA,EAAG;IACnB,IAAIV,WAAW;IACf,IAAI;MACA,OAAO,MAAM,IAAI,CAACI,mBAAmB,EAAE;IAC3C,CAAC,CACD,OAAOc,KAAK,EAAE;MACVC,OAAO,CAACC,IAAI,CAAE,6DAA4D3B,oBAAqB,EAAC,CAAC;MACjG,OAAOA,oBAAoB;IAC/B;EACJ;EACAkB,WAAWA,CAACH,YAAY,EAAEC,SAAS,EAAET,WAAW,EAAE;IAC9C,MAAMqB,QAAQ,GAAGb,YAAY,CAACc,aAAa,EAAE;IAC7C,OAAQD,QAAQ,GAAGrB,WAAW,IAC1BQ,YAAY,CAACe,cAAc,CAACd,SAAS,CAACe,SAAS,CAAC,IAChD,IAAI,CAACC,gBAAgB,CAAChB,SAAS,CAACe,SAAS,CAAC;EAClD;EACAC,gBAAgBA,CAACD,SAAS,EAAE;IACxB,OAAOA,SAAS,KAAK,YAAY,IAAIA,SAAS,KAAK,WAAW;EAClE;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}