{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { toUint8Array } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey as _getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport var SignatureV4 = /*#__PURE__*/function () {\n  function SignatureV4(_ref) {\n    var applyChecksum = _ref.applyChecksum,\n      credentials = _ref.credentials,\n      region = _ref.region,\n      service = _ref.service,\n      sha256 = _ref.sha256,\n      _ref$uriEscapePath = _ref.uriEscapePath,\n      uriEscapePath = _ref$uriEscapePath === void 0 ? true : _ref$uriEscapePath;\n    _classCallCheck(this, SignatureV4);\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeProvider(region);\n    this.credentialProvider = normalizeProvider(credentials);\n  }\n  _createClass(SignatureV4, [{\n    key: \"presign\",\n    value: function () {\n      var _presign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(originalRequest) {\n        var options,\n          _options$signingDate,\n          signingDate,\n          _options$expiresIn,\n          expiresIn,\n          unsignableHeaders,\n          unhoistableHeaders,\n          signableHeaders,\n          signingRegion,\n          signingService,\n          credentials,\n          region,\n          _formatDate,\n          longDate,\n          shortDate,\n          scope,\n          request,\n          canonicalHeaders,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n              _options$signingDate = options.signingDate, signingDate = _options$signingDate === void 0 ? new Date() : _options$signingDate, _options$expiresIn = options.expiresIn, expiresIn = _options$expiresIn === void 0 ? 3600 : _options$expiresIn, unsignableHeaders = options.unsignableHeaders, unhoistableHeaders = options.unhoistableHeaders, signableHeaders = options.signableHeaders, signingRegion = options.signingRegion, signingService = options.signingService;\n              _context.next = 4;\n              return this.credentialProvider();\n            case 4:\n              credentials = _context.sent;\n              this.validateResolvedCredentials(credentials);\n              if (!(signingRegion !== null && signingRegion !== void 0)) {\n                _context.next = 10;\n                break;\n              }\n              _context.t0 = signingRegion;\n              _context.next = 13;\n              break;\n            case 10:\n              _context.next = 12;\n              return this.regionProvider();\n            case 12:\n              _context.t0 = _context.sent;\n            case 13:\n              region = _context.t0;\n              _formatDate = formatDate(signingDate), longDate = _formatDate.longDate, shortDate = _formatDate.shortDate;\n              if (!(expiresIn > MAX_PRESIGNED_TTL)) {\n                _context.next = 17;\n                break;\n              }\n              return _context.abrupt(\"return\", Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\"));\n            case 17:\n              scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n              request = moveHeadersToQuery(prepareRequest(originalRequest), {\n                unhoistableHeaders: unhoistableHeaders\n              });\n              if (credentials.sessionToken) {\n                request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n              }\n              request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n              request.query[CREDENTIAL_QUERY_PARAM] = \"\".concat(credentials.accessKeyId, \"/\").concat(scope);\n              request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n              request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n              canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n              request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n              _context.t1 = this;\n              _context.t2 = longDate;\n              _context.t3 = scope;\n              _context.t4 = this.getSigningKey(credentials, region, shortDate, signingService);\n              _context.t5 = this;\n              _context.t6 = request;\n              _context.t7 = canonicalHeaders;\n              _context.next = 35;\n              return getPayloadHash(originalRequest, this.sha256);\n            case 35:\n              _context.t8 = _context.sent;\n              _context.t9 = _context.t5.createCanonicalRequest.call(_context.t5, _context.t6, _context.t7, _context.t8);\n              _context.next = 39;\n              return _context.t1.getSignature.call(_context.t1, _context.t2, _context.t3, _context.t4, _context.t9);\n            case 39:\n              request.query[SIGNATURE_QUERY_PARAM] = _context.sent;\n              return _context.abrupt(\"return\", request);\n            case 41:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function presign(_x) {\n        return _presign.apply(this, arguments);\n      }\n      return presign;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(toSign, options) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(typeof toSign === \"string\")) {\n                _context2.next = 4;\n                break;\n              }\n              return _context2.abrupt(\"return\", this.signString(toSign, options));\n            case 4:\n              if (!(toSign.headers && toSign.payload)) {\n                _context2.next = 8;\n                break;\n              }\n              return _context2.abrupt(\"return\", this.signEvent(toSign, options));\n            case 8:\n              return _context2.abrupt(\"return\", this.signRequest(toSign, options));\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function sign(_x2, _x3) {\n        return _sign.apply(this, arguments);\n      }\n      return sign;\n    }()\n  }, {\n    key: \"signEvent\",\n    value: function () {\n      var _signEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref2, _ref3) {\n        var headers, payload, _ref3$signingDate, signingDate, priorSignature, signingRegion, signingService, region, _formatDate2, shortDate, longDate, scope, hashedPayload, hash, hashedHeaders, stringToSign;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              headers = _ref2.headers, payload = _ref2.payload;\n              _ref3$signingDate = _ref3.signingDate, signingDate = _ref3$signingDate === void 0 ? new Date() : _ref3$signingDate, priorSignature = _ref3.priorSignature, signingRegion = _ref3.signingRegion, signingService = _ref3.signingService;\n              if (!(signingRegion !== null && signingRegion !== void 0)) {\n                _context3.next = 6;\n                break;\n              }\n              _context3.t0 = signingRegion;\n              _context3.next = 9;\n              break;\n            case 6:\n              _context3.next = 8;\n              return this.regionProvider();\n            case 8:\n              _context3.t0 = _context3.sent;\n            case 9:\n              region = _context3.t0;\n              _formatDate2 = formatDate(signingDate), shortDate = _formatDate2.shortDate, longDate = _formatDate2.longDate;\n              scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n              _context3.next = 14;\n              return getPayloadHash({\n                headers: {},\n                body: payload\n              }, this.sha256);\n            case 14:\n              hashedPayload = _context3.sent;\n              hash = new this.sha256();\n              hash.update(headers);\n              _context3.t1 = toHex;\n              _context3.next = 20;\n              return hash.digest();\n            case 20:\n              _context3.t2 = _context3.sent;\n              hashedHeaders = (0, _context3.t1)(_context3.t2);\n              stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n              return _context3.abrupt(\"return\", this.signString(stringToSign, {\n                signingDate: signingDate,\n                signingRegion: region,\n                signingService: signingService\n              }));\n            case 24:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function signEvent(_x4, _x5) {\n        return _signEvent.apply(this, arguments);\n      }\n      return signEvent;\n    }()\n  }, {\n    key: \"signString\",\n    value: function () {\n      var _signString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(stringToSign) {\n        var _ref4,\n          _ref4$signingDate,\n          signingDate,\n          signingRegion,\n          signingService,\n          credentials,\n          region,\n          _formatDate3,\n          shortDate,\n          hash,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _ref4 = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {}, _ref4$signingDate = _ref4.signingDate, signingDate = _ref4$signingDate === void 0 ? new Date() : _ref4$signingDate, signingRegion = _ref4.signingRegion, signingService = _ref4.signingService;\n              _context4.next = 3;\n              return this.credentialProvider();\n            case 3:\n              credentials = _context4.sent;\n              this.validateResolvedCredentials(credentials);\n              if (!(signingRegion !== null && signingRegion !== void 0)) {\n                _context4.next = 9;\n                break;\n              }\n              _context4.t0 = signingRegion;\n              _context4.next = 12;\n              break;\n            case 9:\n              _context4.next = 11;\n              return this.regionProvider();\n            case 11:\n              _context4.t0 = _context4.sent;\n            case 12:\n              region = _context4.t0;\n              _formatDate3 = formatDate(signingDate), shortDate = _formatDate3.shortDate;\n              _context4.t1 = this.sha256;\n              _context4.next = 17;\n              return this.getSigningKey(credentials, region, shortDate, signingService);\n            case 17:\n              _context4.t2 = _context4.sent;\n              hash = new _context4.t1(_context4.t2);\n              hash.update(toUint8Array(stringToSign));\n              _context4.t3 = toHex;\n              _context4.next = 23;\n              return hash.digest();\n            case 23:\n              _context4.t4 = _context4.sent;\n              return _context4.abrupt(\"return\", (0, _context4.t3)(_context4.t4));\n            case 25:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function signString(_x6) {\n        return _signString.apply(this, arguments);\n      }\n      return signString;\n    }()\n  }, {\n    key: \"signRequest\",\n    value: function () {\n      var _signRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(requestToSign) {\n        var _ref5,\n          _ref5$signingDate,\n          signingDate,\n          signableHeaders,\n          unsignableHeaders,\n          signingRegion,\n          signingService,\n          credentials,\n          region,\n          request,\n          _formatDate4,\n          longDate,\n          shortDate,\n          scope,\n          payloadHash,\n          canonicalHeaders,\n          signature,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _ref5 = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {}, _ref5$signingDate = _ref5.signingDate, signingDate = _ref5$signingDate === void 0 ? new Date() : _ref5$signingDate, signableHeaders = _ref5.signableHeaders, unsignableHeaders = _ref5.unsignableHeaders, signingRegion = _ref5.signingRegion, signingService = _ref5.signingService;\n              _context5.next = 3;\n              return this.credentialProvider();\n            case 3:\n              credentials = _context5.sent;\n              this.validateResolvedCredentials(credentials);\n              if (!(signingRegion !== null && signingRegion !== void 0)) {\n                _context5.next = 9;\n                break;\n              }\n              _context5.t0 = signingRegion;\n              _context5.next = 12;\n              break;\n            case 9:\n              _context5.next = 11;\n              return this.regionProvider();\n            case 11:\n              _context5.t0 = _context5.sent;\n            case 12:\n              region = _context5.t0;\n              request = prepareRequest(requestToSign);\n              _formatDate4 = formatDate(signingDate), longDate = _formatDate4.longDate, shortDate = _formatDate4.shortDate;\n              scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);\n              request.headers[AMZ_DATE_HEADER] = longDate;\n              if (credentials.sessionToken) {\n                request.headers[TOKEN_HEADER] = credentials.sessionToken;\n              }\n              _context5.next = 20;\n              return getPayloadHash(request, this.sha256);\n            case 20:\n              payloadHash = _context5.sent;\n              if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n                request.headers[SHA256_HEADER] = payloadHash;\n              }\n              canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n              _context5.next = 25;\n              return this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n            case 25:\n              signature = _context5.sent;\n              request.headers[AUTH_HEADER] = \"\".concat(ALGORITHM_IDENTIFIER, \" \") + \"Credential=\".concat(credentials.accessKeyId, \"/\").concat(scope, \", \") + \"SignedHeaders=\".concat(getCanonicalHeaderList(canonicalHeaders), \", \") + \"Signature=\".concat(signature);\n              return _context5.abrupt(\"return\", request);\n            case 28:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function signRequest(_x7) {\n        return _signRequest.apply(this, arguments);\n      }\n      return signRequest;\n    }()\n  }, {\n    key: \"createCanonicalRequest\",\n    value: function createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n      var sortedHeaders = Object.keys(canonicalHeaders).sort();\n      return \"\".concat(request.method, \"\\n\").concat(this.getCanonicalPath(request), \"\\n\").concat(getCanonicalQuery(request), \"\\n\").concat(sortedHeaders.map(function (name) {\n        return \"\".concat(name, \":\").concat(canonicalHeaders[name]);\n      }).join(\"\\n\"), \"\\n\\n\").concat(sortedHeaders.join(\";\"), \"\\n\").concat(payloadHash);\n    }\n  }, {\n    key: \"createStringToSign\",\n    value: function () {\n      var _createStringToSign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(longDate, credentialScope, canonicalRequest) {\n        var hash, hashedRequest;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              hash = new this.sha256();\n              hash.update(toUint8Array(canonicalRequest));\n              _context6.next = 4;\n              return hash.digest();\n            case 4:\n              hashedRequest = _context6.sent;\n              return _context6.abrupt(\"return\", \"\".concat(ALGORITHM_IDENTIFIER, \"\\n\").concat(longDate, \"\\n\").concat(credentialScope, \"\\n\").concat(toHex(hashedRequest)));\n            case 6:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function createStringToSign(_x8, _x9, _x10) {\n        return _createStringToSign.apply(this, arguments);\n      }\n      return createStringToSign;\n    }()\n  }, {\n    key: \"getCanonicalPath\",\n    value: function getCanonicalPath(_ref6) {\n      var path = _ref6.path;\n      if (this.uriEscapePath) {\n        var normalizedPathSegments = [];\n        var _iterator = _createForOfIteratorHelper(path.split(\"/\")),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var pathSegment = _step.value;\n            if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0) continue;\n            if (pathSegment === \".\") continue;\n            if (pathSegment === \"..\") {\n              normalizedPathSegments.pop();\n            } else {\n              normalizedPathSegments.push(pathSegment);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var normalizedPath = \"\".concat(path !== null && path !== void 0 && path.startsWith(\"/\") ? \"/\" : \"\").concat(normalizedPathSegments.join(\"/\")).concat(normalizedPathSegments.length > 0 && path !== null && path !== void 0 && path.endsWith(\"/\") ? \"/\" : \"\");\n        var doubleEncoded = encodeURIComponent(normalizedPath);\n        return doubleEncoded.replace(/%2F/g, \"/\");\n      }\n      return path;\n    }\n  }, {\n    key: \"getSignature\",\n    value: function () {\n      var _getSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(longDate, credentialScope, keyPromise, canonicalRequest) {\n        var stringToSign, hash;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this.createStringToSign(longDate, credentialScope, canonicalRequest);\n            case 2:\n              stringToSign = _context7.sent;\n              _context7.t0 = this.sha256;\n              _context7.next = 6;\n              return keyPromise;\n            case 6:\n              _context7.t1 = _context7.sent;\n              hash = new _context7.t0(_context7.t1);\n              hash.update(toUint8Array(stringToSign));\n              _context7.t2 = toHex;\n              _context7.next = 12;\n              return hash.digest();\n            case 12:\n              _context7.t3 = _context7.sent;\n              return _context7.abrupt(\"return\", (0, _context7.t2)(_context7.t3));\n            case 14:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function getSignature(_x11, _x12, _x13, _x14) {\n        return _getSignature.apply(this, arguments);\n      }\n      return getSignature;\n    }()\n  }, {\n    key: \"getSigningKey\",\n    value: function getSigningKey(credentials, region, shortDate, service) {\n      return _getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n    }\n  }, {\n    key: \"validateResolvedCredentials\",\n    value: function validateResolvedCredentials(credentials) {\n      if (typeof credentials !== \"object\" || typeof credentials.accessKeyId !== \"string\" || typeof credentials.secretAccessKey !== \"string\") {\n        throw new Error(\"Resolved credential object is not valid\");\n      }\n    }\n  }]);\n  return SignatureV4;\n}();\nvar formatDate = function formatDate(now) {\n  var longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate: longDate,\n    shortDate: longDate.slice(0, 8)\n  };\n};\nvar getCanonicalHeaderList = function getCanonicalHeaderList(headers) {\n  return Object.keys(headers).sort().join(\";\");\n};","map":{"version":3,"names":["toHex","normalizeProvider","toUint8Array","ALGORITHM_IDENTIFIER","ALGORITHM_QUERY_PARAM","AMZ_DATE_HEADER","AMZ_DATE_QUERY_PARAM","AUTH_HEADER","CREDENTIAL_QUERY_PARAM","EVENT_ALGORITHM_IDENTIFIER","EXPIRES_QUERY_PARAM","MAX_PRESIGNED_TTL","SHA256_HEADER","SIGNATURE_QUERY_PARAM","SIGNED_HEADERS_QUERY_PARAM","TOKEN_HEADER","TOKEN_QUERY_PARAM","createScope","getSigningKey","getCanonicalHeaders","getCanonicalQuery","getPayloadHash","hasHeader","moveHeadersToQuery","prepareRequest","iso8601","SignatureV4","_ref","applyChecksum","credentials","region","service","sha256","_ref$uriEscapePath","uriEscapePath","_classCallCheck","regionProvider","credentialProvider","_createClass","key","value","_presign","_asyncToGenerator","_regeneratorRuntime","mark","_callee","originalRequest","options","_options$signingDate","signingDate","_options$expiresIn","expiresIn","unsignableHeaders","unhoistableHeaders","signableHeaders","signingRegion","signingService","_formatDate","longDate","shortDate","scope","request","canonicalHeaders","_args","arguments","wrap","_callee$","_context","prev","next","length","undefined","Date","sent","validateResolvedCredentials","t0","formatDate","abrupt","Promise","reject","sessionToken","query","concat","accessKeyId","toString","getCanonicalHeaderList","t1","t2","t3","t4","t5","t6","t7","t8","t9","createCanonicalRequest","call","getSignature","stop","presign","_x","apply","_sign","_callee2","toSign","_callee2$","_context2","signString","headers","payload","signEvent","signRequest","sign","_x2","_x3","_signEvent","_callee3","_ref2","_ref3","_ref3$signingDate","priorSignature","_formatDate2","hashedPayload","hash","hashedHeaders","stringToSign","_callee3$","_context3","body","update","digest","join","_x4","_x5","_signString","_callee4","_ref4","_ref4$signingDate","_formatDate3","_args4","_callee4$","_context4","_x6","_signRequest","_callee5","requestToSign","_ref5","_ref5$signingDate","_formatDate4","payloadHash","signature","_args5","_callee5$","_context5","_x7","sortedHeaders","Object","keys","sort","method","getCanonicalPath","map","name","_createStringToSign","_callee6","credentialScope","canonicalRequest","hashedRequest","_callee6$","_context6","createStringToSign","_x8","_x9","_x10","_ref6","path","normalizedPathSegments","_iterator","_createForOfIteratorHelper","split","_step","s","n","done","pathSegment","pop","push","err","e","f","normalizedPath","startsWith","endsWith","doubleEncoded","encodeURIComponent","replace","_getSignature","_callee7","keyPromise","_callee7$","_context7","_x11","_x12","_x13","_x14","secretAccessKey","Error","now","slice"],"sources":["/Users/ericli/Desktop/pill2/node_modules/@aws-sdk/client-s3/node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js"],"sourcesContent":["import { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { toUint8Array } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4 {\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        this.service = service;\n        this.sha256 = sha256;\n        this.uriEscapePath = uriEscapePath;\n        this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n        this.regionProvider = normalizeProvider(region);\n        this.credentialProvider = normalizeProvider(credentials);\n    }\n    async presign(originalRequest, options = {}) {\n        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { longDate, shortDate } = formatDate(signingDate);\n        if (expiresIn > MAX_PRESIGNED_TTL) {\n            return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n        }\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });\n        if (credentials.sessionToken) {\n            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n        }\n        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n        request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n        return request;\n    }\n    async sign(toSign, options) {\n        if (typeof toSign === \"string\") {\n            return this.signString(toSign, options);\n        }\n        else if (toSign.headers && toSign.payload) {\n            return this.signEvent(toSign, options);\n        }\n        else {\n            return this.signRequest(toSign, options);\n        }\n    }\n    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate, longDate } = formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);\n        const hash = new this.sha256();\n        hash.update(headers);\n        const hashedHeaders = toHex(await hash.digest());\n        const stringToSign = [\n            EVENT_ALGORITHM_IDENTIFIER,\n            longDate,\n            scope,\n            priorSignature,\n            hashedHeaders,\n            hashedPayload,\n        ].join(\"\\n\");\n        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n    }\n    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate } = formatDate(signingDate);\n        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const request = prepareRequest(requestToSign);\n        const { longDate, shortDate } = formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        request.headers[AMZ_DATE_HEADER] = longDate;\n        if (credentials.sessionToken) {\n            request.headers[TOKEN_HEADER] = credentials.sessionToken;\n        }\n        const payloadHash = await getPayloadHash(request, this.sha256);\n        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n            request.headers[SHA256_HEADER] = payloadHash;\n        }\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n        request.headers[AUTH_HEADER] =\n            `${ALGORITHM_IDENTIFIER} ` +\n                `Credential=${credentials.accessKeyId}/${scope}, ` +\n                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +\n                `Signature=${signature}`;\n        return request;\n    }\n    createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort();\n        return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n    }\n    async createStringToSign(longDate, credentialScope, canonicalRequest) {\n        const hash = new this.sha256();\n        hash.update(toUint8Array(canonicalRequest));\n        const hashedRequest = await hash.digest();\n        return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n    }\n    getCanonicalPath({ path }) {\n        if (this.uriEscapePath) {\n            const normalizedPathSegments = [];\n            for (const pathSegment of path.split(\"/\")) {\n                if (pathSegment?.length === 0)\n                    continue;\n                if (pathSegment === \".\")\n                    continue;\n                if (pathSegment === \"..\") {\n                    normalizedPathSegments.pop();\n                }\n                else {\n                    normalizedPathSegments.push(pathSegment);\n                }\n            }\n            const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n            const doubleEncoded = encodeURIComponent(normalizedPath);\n            return doubleEncoded.replace(/%2F/g, \"/\");\n        }\n        return path;\n    }\n    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n        const hash = new this.sha256(await keyPromise);\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    getSigningKey(credentials, region, shortDate, service) {\n        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n    }\n    validateResolvedCredentials(credentials) {\n        if (typeof credentials !== \"object\" ||\n            typeof credentials.accessKeyId !== \"string\" ||\n            typeof credentials.secretAccessKey !== \"string\") {\n            throw new Error(\"Resolved credential object is not valid\");\n        }\n    }\n}\nconst formatDate = (now) => {\n    const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n    return {\n        longDate,\n        shortDate: longDate.slice(0, 8),\n    };\n};\nconst getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(\";\");\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}