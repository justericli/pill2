{"ast":null,"code":"import { __assign, __asyncValues, __awaiter, __generator, __read, __spread, __values } from \"tslib\";\nimport { PredicateInternalsKey } from '../types';\nimport { ModelPredicateCreator as FlatModelPredicateCreator, comparisonKeys } from './index';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\nvar ops = __spread(comparisonKeys);\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nvar predicateInternalsMap = new Map();\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nvar registerPredicateInternals = function (condition, key) {\n  var finalKey = key || new PredicateInternalsKey();\n  predicateInternalsMap.set(finalKey, condition);\n  return finalKey;\n};\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport var internals = function (key) {\n  if (!predicateInternalsMap.has(key)) {\n    throw new Error(\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\");\n  }\n  return predicateInternalsMap.get(key);\n};\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nvar negations = {\n  and: 'or',\n  or: 'and',\n  not: 'and',\n  eq: 'ne',\n  ne: 'eq',\n  gt: 'le',\n  ge: 'lt',\n  lt: 'ge',\n  le: 'gt',\n  contains: 'notContains',\n  notContains: 'contains'\n};\n/**\n * Given a V1 predicate \"seed\", applies a list of V2 field-level conditions\n * to the predicate, returning a new/final V1 predicate chain link.\n * @param predicate The base/seed V1 predicate to build on\n * @param conditions The V2 conditions to add to the predicate chain.\n * @param negateChildren Whether the conditions should be negated first.\n * @returns A V1 predicate, with conditions incorporated.\n */\nfunction applyConditionsToV1Predicate(predicate, conditions, negateChildren) {\n  var e_1, _a, e_2, _b;\n  var p = predicate;\n  var finalConditions = [];\n  try {\n    for (var conditions_1 = __values(conditions), conditions_1_1 = conditions_1.next(); !conditions_1_1.done; conditions_1_1 = conditions_1.next()) {\n      var c = conditions_1_1.value;\n      if (negateChildren) {\n        if (c.operator === 'between') {\n          finalConditions.push(new FieldCondition(c.field, 'lt', [c.operands[0]]), new FieldCondition(c.field, 'gt', [c.operands[1]]));\n        } else {\n          finalConditions.push(new FieldCondition(c.field, negations[c.operator], c.operands));\n        }\n      } else {\n        finalConditions.push(c);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (conditions_1_1 && !conditions_1_1.done && (_a = conditions_1.return)) _a.call(conditions_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  try {\n    for (var finalConditions_1 = __values(finalConditions), finalConditions_1_1 = finalConditions_1.next(); !finalConditions_1_1.done; finalConditions_1_1 = finalConditions_1.next()) {\n      var c = finalConditions_1_1.value;\n      p = p[c.field](c.operator, c.operator === 'between' ? c.operands : c.operands[0]);\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (finalConditions_1_1 && !finalConditions_1_1.done && (_b = finalConditions_1.return)) _b.call(finalConditions_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n  return p;\n}\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nvar FieldCondition = /** @class */function () {\n  function FieldCondition(field, operator, operands) {\n    this.field = field;\n    this.operator = operator;\n    this.operands = operands;\n    this.validate();\n  }\n  /**\n   * Creates a copy of self.\n   * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n   * @returns A new, identitical `FieldCondition`.\n   */\n  FieldCondition.prototype.copy = function (extract) {\n    return [new FieldCondition(this.field, this.operator, __spread(this.operands)), undefined];\n  };\n  FieldCondition.prototype.toAST = function () {\n    var _a, _b;\n    return _a = {}, _a[this.field] = (_b = {}, _b[this.operator] = this.operator === 'between' ? [this.operands[0], this.operands[1]] : this.operands[0], _b), _a;\n  };\n  /**\n   * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n   * transforms them into legacy predicates. (*For now.*)\n   * @param storage N/A. If ever implemented, the storage adapter to query.\n   * @returns N/A. If ever implemented, return items from `storage` that match.\n   */\n  FieldCondition.prototype.fetch = function (storage) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, Promise.reject('No implementation needed [yet].')];\n      });\n    });\n  };\n  /**\n   * Determins whether a given item matches the expressed condition.\n   * @param item The item to test.\n   * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n   */\n  FieldCondition.prototype.matches = function (item) {\n    return __awaiter(this, void 0, void 0, function () {\n      var v, operations, operation, result;\n      var _this = this;\n      return __generator(this, function (_a) {\n        v = item[this.field];\n        operations = {\n          eq: function () {\n            return v === _this.operands[0];\n          },\n          ne: function () {\n            return v !== _this.operands[0];\n          },\n          gt: function () {\n            return v > _this.operands[0];\n          },\n          ge: function () {\n            return v >= _this.operands[0];\n          },\n          lt: function () {\n            return v < _this.operands[0];\n          },\n          le: function () {\n            return v <= _this.operands[0];\n          },\n          contains: function () {\n            return v.indexOf(_this.operands[0]) > -1;\n          },\n          notContains: function () {\n            return v.indexOf(_this.operands[0]) === -1;\n          },\n          beginsWith: function () {\n            return v.startsWith(_this.operands[0]);\n          },\n          between: function () {\n            return v >= _this.operands[0] && v <= _this.operands[1];\n          }\n        };\n        operation = operations[this.operator];\n        if (operation) {\n          result = operation();\n          return [2 /*return*/, result];\n        } else {\n          throw new Error(\"Invalid operator given: \" + this.operator);\n        }\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\n   * Checks `this.operands` for compatibility with `this.operator`.\n   */\n  FieldCondition.prototype.validate = function () {\n    var _this = this;\n    /**\n     * Creates a validator that checks for a particular `operands` count.\n     * Throws an exception if the `count` disagrees with `operands.length`.\n     * @param count The number of `operands` expected.\n     */\n    var argumentCount = function (count) {\n      var argsClause = count === 1 ? 'argument is' : 'arguments are';\n      return function () {\n        if (_this.operands.length !== count) {\n          return \"Exactly \" + count + \" \" + argsClause + \" required.\";\n        }\n      };\n    };\n    // NOTE: validations should return a message on failure.\n    // hence, they should be \"joined\" together with logical OR's\n    // as seen in the `between:` entry.\n    var validations = {\n      eq: argumentCount(1),\n      ne: argumentCount(1),\n      gt: argumentCount(1),\n      ge: argumentCount(1),\n      lt: argumentCount(1),\n      le: argumentCount(1),\n      contains: argumentCount(1),\n      notContains: argumentCount(1),\n      beginsWith: argumentCount(1),\n      between: function () {\n        return argumentCount(2)() || (_this.operands[0] > _this.operands[1] ? 'The first argument must be less than or equal to the second argument.' : null);\n      }\n    };\n    var validate = validations[this.operator];\n    if (validate) {\n      var e = validate();\n      if (typeof e === 'string') throw new Error(\"Incorrect usage of `\" + this.operator + \"()`: \" + e);\n    } else {\n      throw new Error(\"Non-existent operator: `\" + this.operator + \"()`\");\n    }\n  };\n  return FieldCondition;\n}();\nexport { FieldCondition };\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nvar getGroupId = function () {\n  var seed = 1;\n  return function () {\n    return \"group_\" + seed++;\n  };\n}();\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nvar GroupCondition = /** @class */function () {\n  function GroupCondition(\n  /**\n   * The `ModelMeta` of the model to query and/or filter against.\n   * Expected to contain:\n   *\n   * ```js\n   * {\n   * \tbuilder: ModelConstructor,\n   * \tschema: SchemaModel,\n   * \tpkField: string[]\n   * }\n   * ```\n   */\n  model,\n  /**\n   * If populated, this group specifices a condition on a relationship.\n   *\n   * If `field` does *not* point to a related model, that's an error. It\n   * could indicate that the `GroupCondition` was instantiated with bad\n   * data, or that the model metadata is incorrect.\n   */\n  field,\n  /**\n   * If a `field` is given, whether the relationship is a `HAS_ONE`,\n   * 'HAS_MANY`, or `BELONGS_TO`.\n   *\n   * TODO: Remove this and replace with derivation using\n   * `ModelRelationship.from(this.model, this.field).relationship`;\n   */\n  relationshipType,\n  /**\n   *\n   */\n  operator,\n  /**\n   *\n   */\n  operands) {\n    this.model = model;\n    this.field = field;\n    this.relationshipType = relationshipType;\n    this.operator = operator;\n    this.operands = operands;\n    // `groupId` was used for development/debugging.\n    // Should we leave this in for future troubleshooting?\n    this.groupId = getGroupId();\n  }\n  /**\n   * Returns a copy of a GroupCondition, which also returns the copy of a\n   * given reference node to \"extract\".\n   * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n   * @returns [The full copy, the copy of `extract` | undefined]\n   */\n  GroupCondition.prototype.copy = function (extract) {\n    var copied = new GroupCondition(this.model, this.field, this.relationshipType, this.operator, []);\n    var extractedCopy = extract === this ? copied : undefined;\n    this.operands.forEach(function (o) {\n      var _a = __read(o.copy(extract), 2),\n        operandCopy = _a[0],\n        extractedFromOperand = _a[1];\n      copied.operands.push(operandCopy);\n      extractedCopy = extractedCopy || extractedFromOperand;\n    });\n    return [copied, extractedCopy];\n  };\n  /**\n   * Fetches matching records from a given storage adapter using legacy predicates (for now).\n   * @param storage The storage adapter this predicate will query against.\n   * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n   * GroupdCondition.fetch is nested within.\n   * @param negate Whether to match on the `NOT` of `this`.\n   * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n   */\n  GroupCondition.prototype.fetch = function (storage, breadcrumb, negate) {\n    if (breadcrumb === void 0) {\n      breadcrumb = [];\n    }\n    if (negate === void 0) {\n      negate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var resultGroups, operator, negateChildren, groups, conditions, groups_1, groups_1_1, g, relatives, relationship, relativesPredicates, _loop_1, relatives_1, relatives_1_1, relative, predicate, _a, _b, e_3_1, predicate, _c, _d, _e, _f, getPKValue, resultIndex, resultGroups_1, resultGroups_1_1, group, intersectWith, _g, _h, k, resultGroups_2, resultGroups_2_1, group, group_1, group_1_1, item;\n      var e_3, _j, e_4, _k, e_5, _l, e_6, _m, e_7, _o, e_8, _p;\n      var _this = this;\n      return __generator(this, function (_q) {\n        switch (_q.label) {\n          case 0:\n            resultGroups = [];\n            operator = negate ? negations[this.operator] : this.operator;\n            negateChildren = negate !== (this.operator === 'not');\n            groups = this.operands.filter(function (op) {\n              return op instanceof GroupCondition;\n            });\n            conditions = this.operands.filter(function (op) {\n              return op instanceof FieldCondition;\n            });\n            _q.label = 1;\n          case 1:\n            _q.trys.push([1, 10, 11, 12]);\n            groups_1 = __values(groups), groups_1_1 = groups_1.next();\n            _q.label = 2;\n          case 2:\n            if (!!groups_1_1.done) return [3 /*break*/, 9];\n            g = groups_1_1.value;\n            return [4 /*yield*/, g.fetch(storage, __spread(breadcrumb, [this.groupId]), negateChildren)];\n          case 3:\n            relatives = _q.sent();\n            // no relatives -> no need to attempt to perform a \"join\" query for\n            // candidate results:\n            //\n            // select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n            //\n            // Additionally, the entire (sub)-query can be short-circuited if\n            // the operator is `AND`. Illustrated in SQL:\n            //\n            // select a.* from a where\n            //   id in [a,b,c]\n            //     AND                        <\n            //   id in EMTPY_SET            <<< Look!\n            //     AND                        <\n            //   id in [x,y,z]\n            //\n            // YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n            //\n            if (relatives.length === 0) {\n              // aggressively short-circuit as soon as we know the group condition will fail\n              if (operator === 'and') {\n                return [2 /*return*/, []];\n              }\n              // less aggressive short-circuit if we know the relatives will produce no\n              // candidate results; but aren't sure yet how this affects the group condition.\n              resultGroups.push([]);\n              return [3 /*break*/, 8];\n            }\n            if (!g.field) return [3 /*break*/, 7];\n            relationship = ModelRelationship.from(this.model, g.field);\n            if (!relationship) return [3 /*break*/, 5];\n            relativesPredicates = [];\n            _loop_1 = function (relative) {\n              var individualRowJoinConditions = [];\n              for (var i = 0; i < relationship.localJoinFields.length; i++) {\n                // rightHandValue\n                individualRowJoinConditions.push(new FieldCondition(relationship.localJoinFields[i], 'eq', [relative[relationship.remoteJoinFields[i]]]));\n              }\n              var predicate_1 = function (p) {\n                return applyConditionsToV1Predicate(p, individualRowJoinConditions, false);\n              };\n              relativesPredicates.push(predicate_1);\n            };\n            try {\n              for (relatives_1 = (e_4 = void 0, __values(relatives)), relatives_1_1 = relatives_1.next(); !relatives_1_1.done; relatives_1_1 = relatives_1.next()) {\n                relative = relatives_1_1.value;\n                _loop_1(relative);\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (relatives_1_1 && !relatives_1_1.done && (_k = relatives_1.return)) _k.call(relatives_1);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n            predicate = FlatModelPredicateCreator.createGroupFromExisting(this.model.schema, 'or', relativesPredicates);\n            _b = (_a = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n          case 4:\n            _b.apply(_a, [_q.sent()]);\n            return [3 /*break*/, 6];\n          case 5:\n            throw new Error('Missing field metadata.');\n          case 6:\n            return [3 /*break*/, 8];\n          case 7:\n            // relatives are not actually relatives. they're candidate results.\n            resultGroups.push(relatives);\n            _q.label = 8;\n          case 8:\n            groups_1_1 = groups_1.next();\n            return [3 /*break*/, 2];\n          case 9:\n            return [3 /*break*/, 12];\n          case 10:\n            e_3_1 = _q.sent();\n            e_3 = {\n              error: e_3_1\n            };\n            return [3 /*break*/, 12];\n          case 11:\n            try {\n              if (groups_1_1 && !groups_1_1.done && (_j = groups_1.return)) _j.call(groups_1);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n            return [7 /*endfinally*/];\n          case 12:\n            if (!(conditions.length > 0)) return [3 /*break*/, 14];\n            predicate = FlatModelPredicateCreator.createFromExisting(this.model.schema, function (p) {\n              return p[operator](function (c) {\n                return applyConditionsToV1Predicate(c, conditions, negateChildren);\n              });\n            });\n            _d = (_c = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder, predicate)];\n          case 13:\n            _d.apply(_c, [_q.sent()]);\n            return [3 /*break*/, 16];\n          case 14:\n            if (!(conditions.length === 0 && resultGroups.length === 0)) return [3 /*break*/, 16];\n            _f = (_e = resultGroups).push;\n            return [4 /*yield*/, storage.query(this.model.builder)];\n          case 15:\n            _f.apply(_e, [_q.sent()]);\n            _q.label = 16;\n          case 16:\n            getPKValue = function (item) {\n              return JSON.stringify(_this.model.pkField.map(function (name) {\n                return item[name];\n              }));\n            };\n            if (operator === 'and') {\n              if (resultGroups.length === 0) {\n                return [2 /*return*/, []];\n              }\n              try {\n                // for each group, we intersect, removing items from the result index\n                // that aren't present in each subsequent group.\n                for (resultGroups_1 = __values(resultGroups), resultGroups_1_1 = resultGroups_1.next(); !resultGroups_1_1.done; resultGroups_1_1 = resultGroups_1.next()) {\n                  group = resultGroups_1_1.value;\n                  if (resultIndex === undefined) {\n                    resultIndex = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                  } else {\n                    intersectWith = new Map(group.map(function (item) {\n                      return [getPKValue(item), item];\n                    }));\n                    try {\n                      for (_g = (e_6 = void 0, __values(resultIndex.keys())), _h = _g.next(); !_h.done; _h = _g.next()) {\n                        k = _h.value;\n                        if (!intersectWith.has(k)) {\n                          resultIndex.delete(k);\n                        }\n                      }\n                    } catch (e_6_1) {\n                      e_6 = {\n                        error: e_6_1\n                      };\n                    } finally {\n                      try {\n                        if (_h && !_h.done && (_m = _g.return)) _m.call(_g);\n                      } finally {\n                        if (e_6) throw e_6.error;\n                      }\n                    }\n                  }\n                }\n              } catch (e_5_1) {\n                e_5 = {\n                  error: e_5_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_1_1 && !resultGroups_1_1.done && (_l = resultGroups_1.return)) _l.call(resultGroups_1);\n                } finally {\n                  if (e_5) throw e_5.error;\n                }\n              }\n            } else if (operator === 'or' || operator === 'not') {\n              // it's OK to handle NOT here, because NOT must always only negate\n              // a single child predicate. NOT logic will have been distributed down\n              // to the leaf conditions already.\n              resultIndex = new Map();\n              try {\n                // just merge the groups, performing DISTINCT-ification by ID.\n                for (resultGroups_2 = __values(resultGroups), resultGroups_2_1 = resultGroups_2.next(); !resultGroups_2_1.done; resultGroups_2_1 = resultGroups_2.next()) {\n                  group = resultGroups_2_1.value;\n                  try {\n                    for (group_1 = (e_8 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {\n                      item = group_1_1.value;\n                      resultIndex.set(getPKValue(item), item);\n                    }\n                  } catch (e_8_1) {\n                    e_8 = {\n                      error: e_8_1\n                    };\n                  } finally {\n                    try {\n                      if (group_1_1 && !group_1_1.done && (_p = group_1.return)) _p.call(group_1);\n                    } finally {\n                      if (e_8) throw e_8.error;\n                    }\n                  }\n                }\n              } catch (e_7_1) {\n                e_7 = {\n                  error: e_7_1\n                };\n              } finally {\n                try {\n                  if (resultGroups_2_1 && !resultGroups_2_1.done && (_o = resultGroups_2.return)) _o.call(resultGroups_2);\n                } finally {\n                  if (e_7) throw e_7.error;\n                }\n              }\n            }\n            return [2 /*return*/, Array.from((resultIndex === null || resultIndex === void 0 ? void 0 : resultIndex.values()) || [])];\n        }\n      });\n    });\n  };\n  /**\n   * Determines whether a single item matches the conditions of `this`.\n   * When checking the target `item`'s properties, each property will be `await`'d\n   * to ensure lazy-loading is respected where applicable.\n   * @param item The item to match against.\n   * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n   * (Used for iterating over children on HAS_MANY checks.)\n   * @returns A boolean (promise): `true` if matched, `false` otherwise.\n   */\n  GroupCondition.prototype.matches = function (item, ignoreFieldName) {\n    if (ignoreFieldName === void 0) {\n      ignoreFieldName = false;\n    }\n    var e_9, _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var itemToCheck, _b, itemToCheck_1, itemToCheck_1_1, singleItem, e_9_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(this.field && !ignoreFieldName)) return [3 /*break*/, 2];\n            return [4 /*yield*/, item[this.field]];\n          case 1:\n            _b = _c.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _b = item;\n            _c.label = 3;\n          case 3:\n            itemToCheck = _b;\n            // if there is no item to check, we can stop recursing immediately.\n            // a condition cannot match against an item that does not exist. this\n            // can occur when `item.field` is optional in the schema.\n            if (!itemToCheck) {\n              return [2 /*return*/, false];\n            }\n            if (!(this.relationshipType === 'HAS_MANY' && typeof itemToCheck[Symbol.asyncIterator] === 'function')) return [3 /*break*/, 17];\n            _c.label = 4;\n          case 4:\n            _c.trys.push([4, 10, 11, 16]);\n            itemToCheck_1 = __asyncValues(itemToCheck);\n            _c.label = 5;\n          case 5:\n            return [4 /*yield*/, itemToCheck_1.next()];\n          case 6:\n            if (!(itemToCheck_1_1 = _c.sent(), !itemToCheck_1_1.done)) return [3 /*break*/, 9];\n            singleItem = itemToCheck_1_1.value;\n            return [4 /*yield*/, this.matches(singleItem, true)];\n          case 7:\n            if (_c.sent()) {\n              return [2 /*return*/, true];\n            }\n            _c.label = 8;\n          case 8:\n            return [3 /*break*/, 5];\n          case 9:\n            return [3 /*break*/, 16];\n          case 10:\n            e_9_1 = _c.sent();\n            e_9 = {\n              error: e_9_1\n            };\n            return [3 /*break*/, 16];\n          case 11:\n            _c.trys.push([11,, 14, 15]);\n            if (!(itemToCheck_1_1 && !itemToCheck_1_1.done && (_a = itemToCheck_1.return))) return [3 /*break*/, 13];\n            return [4 /*yield*/, _a.call(itemToCheck_1)];\n          case 12:\n            _c.sent();\n            _c.label = 13;\n          case 13:\n            return [3 /*break*/, 15];\n          case 14:\n            if (e_9) throw e_9.error;\n            return [7 /*endfinally*/];\n          case 15:\n            return [7 /*endfinally*/];\n          case 16:\n            return [2 /*return*/, false];\n          case 17:\n            if (!(this.operator === 'or')) return [3 /*break*/, 18];\n            return [2 /*return*/, asyncSome(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n          case 18:\n            if (!(this.operator === 'and')) return [3 /*break*/, 19];\n            return [2 /*return*/, asyncEvery(this.operands, function (c) {\n              return c.matches(itemToCheck);\n            })];\n          case 19:\n            if (!(this.operator === 'not')) return [3 /*break*/, 21];\n            if (this.operands.length !== 1) {\n              throw new Error('Invalid arguments! `not()` accepts exactly one predicate expression.');\n            }\n            return [4 /*yield*/, this.operands[0].matches(itemToCheck)];\n          case 20:\n            return [2 /*return*/, !_c.sent()];\n          case 21:\n            throw new Error('Invalid group operator!');\n        }\n      });\n    });\n  };\n  /**\n   * Tranfsorm to a AppSync GraphQL compatible AST.\n   * (Does not support filtering in nested types.)\n   */\n  GroupCondition.prototype.toAST = function () {\n    var _a;\n    if (this.field) throw new Error('Nested type conditions are not supported!');\n    return _a = {}, _a[this.operator] = this.operands.map(function (operand) {\n      return operand.toAST();\n    }), _a;\n  };\n  GroupCondition.prototype.toStoragePredicate = function (baseCondition) {\n    return FlatModelPredicateCreator.createFromAST(this.model.schema, this.toAST());\n  };\n  return GroupCondition;\n}();\nexport { GroupCondition };\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * TODO: the sortof-immutable algorithm was originally done to support legacy style\n * predicate branching (`p => p.x.eq(value).y.eq(value)`). i'm not sure this is\n * necessary or beneficial at this point, since we decided that each field condition\n * must flly terminate a branch. is the strong mutation barrier between chain links\n * still necessary or helpful?\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor(ModelType, allowRecursion, field, query, tail) {\n  if (allowRecursion === void 0) {\n    allowRecursion = true;\n  }\n  // to be used if we don't have a base query or tail to build onto\n  var starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n  var baseCondition = query && tail ? query : starter;\n  var tailCondition = query && tail ? tail : starter;\n  // our eventual return object, which can be built upon.\n  // next steps will be to add or(), and(), not(), and field.op() methods.\n  var link = {};\n  registerPredicateInternals(baseCondition, link);\n  var copyLink = function () {\n    var _a = __read(baseCondition.copy(tailCondition), 2),\n      query = _a[0],\n      newTail = _a[1];\n    var newLink = recursivePredicateFor(ModelType, allowRecursion, undefined, query, newTail);\n    return {\n      query: query,\n      newTail: newTail,\n      newLink: newLink\n    };\n  };\n  // Adds .or() and .and() methods to the link.\n  // TODO: If revisiting this code, consider writing a Proxy instead.\n  ['and', 'or'].forEach(function (op) {\n    link[op] = function (builder) {\n      // or() and and() will return a copy of the original link\n      // to head off mutability concerns.\n      var _a = copyLink(),\n        query = _a.query,\n        newTail = _a.newTail;\n      var childConditions = builder(recursivePredicateFor(ModelType, allowRecursion));\n      if (!Array.isArray(childConditions)) {\n        throw new Error(\"Invalid predicate. `\" + op + \"` groups must return an array of child conditions.\");\n      }\n      // the customer will supply a child predicate, which apply to the `model.field`\n      // of the tail GroupCondition.\n      newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, op, childConditions.map(function (c) {\n        return internals(c);\n      })));\n      // FinalPredicate\n      return registerPredicateInternals(query);\n    };\n  });\n  // TODO: If revisiting this code, consider proxy.\n  link.not = function (builder) {\n    // not() will return a copy of the original link\n    // to head off mutability concerns.\n    var _a = copyLink(),\n      query = _a.query,\n      newTail = _a.newTail;\n    // unlike and() and or(), the customer will supply a \"singular\" child predicate.\n    // the difference being: not() does not accept an array of predicate-like objects.\n    // it negates only a *single* predicate subtree.\n    newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new GroupCondition(ModelType, field, undefined, 'not', [internals(builder(recursivePredicateFor(ModelType, allowRecursion)))]));\n    // A `FinalModelPredicate`.\n    // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n    // or query storage: `.__query.fetch(storage)`.\n    return registerPredicateInternals(query);\n  };\n  var _loop_2 = function (fieldName) {\n    Object.defineProperty(link, fieldName, {\n      enumerable: true,\n      get: function () {\n        var def = ModelType.schema.fields[fieldName];\n        if (!def.association) {\n          // we're looking at a value field. we need to return a\n          // \"field matcher object\", which contains all of the comparison\n          // functions ('eq', 'ne', 'gt', etc.), scoped to operate\n          // against the target field (fieldName).\n          return ops.reduce(function (fieldMatcher, operator) {\n            var _a;\n            return __assign(__assign({}, fieldMatcher), (_a = {}, _a[operator] = function () {\n              var operands = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                operands[_i] = arguments[_i];\n              }\n              // build off a fresh copy of the existing `link`, just in case\n              // the same link is being used elsewhere by the customer.\n              var _a = copyLink(),\n                query = _a.query,\n                newTail = _a.newTail;\n              // add the given condition to the link's TAIL node.\n              // remember: the base link might go N nodes deep! e.g.,\n              newTail === null || newTail === void 0 ? void 0 : newTail.operands.push(new FieldCondition(fieldName, operator, operands));\n              // A `FinalModelPredicate`.\n              // Return a thing that can no longer be extended, but instead used to `async filter(items)`\n              // or query storage: `.__query.fetch(storage)`.\n              return registerPredicateInternals(query);\n            }, _a));\n          }, {});\n        } else {\n          if (!allowRecursion) {\n            throw new Error('Predication on releated models is not supported in this context.');\n          } else if (def.association.connectionType === 'BELONGS_TO' || def.association.connectionType === 'HAS_ONE' || def.association.connectionType === 'HAS_MANY') {\n            // the use has just typed '.someRelatedModel'. we need to given them\n            // back a predicate chain.\n            var relatedMeta = def.type.modelConstructor;\n            if (!relatedMeta) {\n              throw new Error('Related model metadata is missing. This is a bug! Please report it.');\n            }\n            // `Model.reletedModelField` returns a copy of the original link,\n            // and will contains copies of internal GroupConditions\n            // to head off mutability concerns.\n            var _a = __read(baseCondition.copy(tailCondition), 2),\n              newquery = _a[0],\n              oldtail = _a[1];\n            var newtail = new GroupCondition(relatedMeta, fieldName, def.association.connectionType, 'and', []);\n            // `oldtail` here refers to the *copy* of the old tail.\n            // so, it's safe to modify at this point. and we need to modify\n            // it to push the *new* tail onto the end of it.\n            oldtail.operands.push(newtail);\n            var newlink = recursivePredicateFor(relatedMeta, allowRecursion, undefined, newquery, newtail);\n            return newlink;\n          } else {\n            throw new Error(\"Related model definition doesn't have a typedef. This is a bug! Please report it.\");\n          }\n        }\n      }\n    });\n  };\n  // For each field on the model schema, we want to add a getter\n  // that creates the appropriate new `link` in the query chain.\n  // TODO: If revisiting, consider a proxy.\n  for (var fieldName in ModelType.schema.fields) {\n    _loop_2(fieldName);\n  }\n  return link;\n}\nexport function predicateFor(ModelType) {\n  return recursivePredicateFor(ModelType, false);\n}","map":{"version":3,"names":["PredicateInternalsKey","ModelPredicateCreator","FlatModelPredicateCreator","comparisonKeys","ModelRelationship","asyncSome","asyncEvery","ops","__spread","predicateInternalsMap","Map","registerPredicateInternals","condition","key","finalKey","set","internals","has","Error","get","negations","and","or","not","eq","ne","gt","ge","lt","le","contains","notContains","applyConditionsToV1Predicate","predicate","conditions","negateChildren","p","finalConditions","conditions_1","__values","conditions_1_1","next","done","c","value","operator","push","FieldCondition","field","operands","finalConditions_1","finalConditions_1_1","validate","prototype","copy","extract","undefined","toAST","_a","_b","fetch","storage","Promise","reject","matches","item","v","operations","_this","indexOf","beginsWith","startsWith","between","operation","result","argumentCount","count","argsClause","length","validations","e","getGroupId","seed","GroupCondition","model","relationshipType","groupId","copied","extractedCopy","forEach","o","__read","operandCopy","extractedFromOperand","breadcrumb","negate","resultGroups","groups","filter","op","groups_1","groups_1_1","g","relatives","_q","sent","relationship","from","relativesPredicates","relative","individualRowJoinConditions","i","localJoinFields","remoteJoinFields","predicate_1","relatives_1","e_4","relatives_1_1","createGroupFromExisting","schema","query","builder","apply","createFromExisting","_d","_c","_f","_e","getPKValue","JSON","stringify","pkField","map","name","resultGroups_1","resultGroups_1_1","group","resultIndex","intersectWith","_g","e_6","keys","_h","k","delete","resultGroups_2","resultGroups_2_1","group_1","e_8","group_1_1","Array","values","ignoreFieldName","itemToCheck","Symbol","asyncIterator","itemToCheck_1","__asyncValues","singleItem","itemToCheck_1_1","operand","toStoragePredicate","baseCondition","createFromAST","recursivePredicateFor","ModelType","allowRecursion","tail","starter","tailCondition","link","copyLink","newTail","newLink","childConditions","isArray","fieldName","Object","defineProperty","enumerable","def","fields","association","reduce","fieldMatcher","__assign","_i","arguments","connectionType","relatedMeta","type","modelConstructor","newquery","oldtail","newtail","newlink","predicateFor"],"sources":["/Users/ericli/node_modules/@aws-amplify/datastore/src/predicates/next.ts"],"sourcesContent":["import {\n\tPersistentModel,\n\tModelFieldType,\n\tModelMeta,\n\tModelPredicate as StoragePredicate,\n\tAllFieldOperators,\n\tPredicateInternalsKey,\n\tV5ModelPredicate as ModelPredicate,\n\tRecursiveModelPredicate,\n\tRecursiveModelPredicateExtender,\n\tRecursiveModelPredicateAggregateExtender,\n} from '../types';\n\nimport {\n\tModelPredicateCreator as FlatModelPredicateCreator,\n\tcomparisonKeys,\n} from './index';\nimport { ExclusiveStorage as StorageAdapter } from '../storage/storage';\nimport { ModelRelationship } from '../storage/relationship';\nimport { asyncSome, asyncEvery } from '../util';\n\nconst ops = [...comparisonKeys] as AllFieldOperators[];\n\ntype GroupOperator = 'and' | 'or' | 'not';\n\ntype UntypedCondition = {\n\tfetch: (storage: StorageAdapter) => Promise<Record<string, any>[]>;\n\tmatches: (item: Record<string, any>) => Promise<boolean>;\n\tcopy(extract: GroupCondition): [UntypedCondition, GroupCondition | undefined];\n\ttoAST(): any;\n};\n\n/**\n * A map from keys (exposed to customers) to the internal predicate data\n * structures invoking code should not muck with.\n */\nconst predicateInternalsMap = new Map<PredicateInternalsKey, GroupCondition>();\n\n/**\n * Creates a link between a key (and generates a key if needed) and an internal\n * `GroupCondition`, which allows us to return a key object instead of the gory\n * conditions details to customers/invoking code.\n *\n * @param condition The internal condition to keep hidden.\n * @param key The object DataStore will use to find the internal condition.\n * If no key is given, an empty one is created.\n */\nconst registerPredicateInternals = (condition: GroupCondition, key?: any) => {\n\tconst finalKey = key || new PredicateInternalsKey();\n\tpredicateInternalsMap.set(finalKey, condition);\n\treturn finalKey;\n};\n\n/**\n * Takes a key object from `registerPredicateInternals()` to fetch an internal\n * `GroupCondition` object, which can then be used to query storage or\n * test/match objects.\n *\n * This indirection exists to hide `GroupCondition` from public interfaces, since\n * `GroupCondition` contains extra methods and properties that public callers\n * should not use.\n *\n * @param key A key object previously returned by `registerPredicateInternals()`\n */\nexport const internals = (key: any) => {\n\tif (!predicateInternalsMap.has(key)) {\n\t\tthrow new Error(\n\t\t\t\"Invalid predicate. Terminate your predicate with a valid condition (e.g., `p => p.field.eq('value')`) or pass `Predicates.ALL`.\"\n\t\t);\n\t}\n\treturn predicateInternalsMap.get(key)!;\n};\n\n/**\n * Maps operators to negated operators.\n * Used to facilitate propagation of negation down a tree of conditions.\n */\nconst negations = {\n\tand: 'or',\n\tor: 'and',\n\tnot: 'and',\n\teq: 'ne',\n\tne: 'eq',\n\tgt: 'le',\n\tge: 'lt',\n\tlt: 'ge',\n\tle: 'gt',\n\tcontains: 'notContains',\n\tnotContains: 'contains',\n};\n\n/**\n * Given a V1 predicate \"seed\", applies a list of V2 field-level conditions\n * to the predicate, returning a new/final V1 predicate chain link.\n * @param predicate The base/seed V1 predicate to build on\n * @param conditions The V2 conditions to add to the predicate chain.\n * @param negateChildren Whether the conditions should be negated first.\n * @returns A V1 predicate, with conditions incorporated.\n */\nfunction applyConditionsToV1Predicate<T>(\n\tpredicate: T,\n\tconditions: FieldCondition[],\n\tnegateChildren: boolean\n): T {\n\tlet p = predicate;\n\tconst finalConditions: FieldCondition[] = [];\n\n\tfor (const c of conditions) {\n\t\tif (negateChildren) {\n\t\t\tif (c.operator === 'between') {\n\t\t\t\tfinalConditions.push(\n\t\t\t\t\tnew FieldCondition(c.field, 'lt', [c.operands[0]]),\n\t\t\t\t\tnew FieldCondition(c.field, 'gt', [c.operands[1]])\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tfinalConditions.push(\n\t\t\t\t\tnew FieldCondition(c.field, negations[c.operator], c.operands)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tfinalConditions.push(c);\n\t\t}\n\t}\n\n\tfor (const c of finalConditions) {\n\t\tp = p[c.field](\n\t\t\tc.operator as never,\n\t\t\t(c.operator === 'between' ? c.operands : c.operands[0]) as never\n\t\t);\n\t}\n\treturn p;\n}\n\n/**\n * A condition that can operate against a single \"primitive\" field of a model or item.\n * @member field The field of *some record* to test against.\n * @member operator The equality or comparison operator to use.\n * @member operands The operands for the equality/comparison check.\n */\nexport class FieldCondition {\n\tconstructor(\n\t\tpublic field: string,\n\t\tpublic operator: string,\n\t\tpublic operands: string[]\n\t) {\n\t\tthis.validate();\n\t}\n\n\t/**\n\t * Creates a copy of self.\n\t * @param extract Not used. Present only to fulfill the `UntypedCondition` interface.\n\t * @returns A new, identitical `FieldCondition`.\n\t */\n\tcopy(extract: GroupCondition): [FieldCondition, GroupCondition | undefined] {\n\t\treturn [\n\t\t\tnew FieldCondition(this.field, this.operator, [...this.operands]),\n\t\t\tundefined,\n\t\t];\n\t}\n\n\ttoAST() {\n\t\treturn {\n\t\t\t[this.field]: {\n\t\t\t\t[this.operator]:\n\t\t\t\t\tthis.operator === 'between'\n\t\t\t\t\t\t? [this.operands[0], this.operands[1]]\n\t\t\t\t\t\t: this.operands[0],\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Not implemented. Not needed. GroupCondition instead consumes FieldConditions and\n\t * transforms them into legacy predicates. (*For now.*)\n\t * @param storage N/A. If ever implemented, the storage adapter to query.\n\t * @returns N/A. If ever implemented, return items from `storage` that match.\n\t */\n\tasync fetch(storage: StorageAdapter): Promise<Record<string, any>[]> {\n\t\treturn Promise.reject('No implementation needed [yet].');\n\t}\n\n\t/**\n\t * Determins whether a given item matches the expressed condition.\n\t * @param item The item to test.\n\t * @returns `Promise<boolean>`, `true` if matches; `false` otherwise.\n\t */\n\tasync matches(item: Record<string, any>): Promise<boolean> {\n\t\tconst v = item[this.field];\n\t\tconst operations = {\n\t\t\teq: () => v === this.operands[0],\n\t\t\tne: () => v !== this.operands[0],\n\t\t\tgt: () => v > this.operands[0],\n\t\t\tge: () => v >= this.operands[0],\n\t\t\tlt: () => v < this.operands[0],\n\t\t\tle: () => v <= this.operands[0],\n\t\t\tcontains: () => v.indexOf(this.operands[0]) > -1,\n\t\t\tnotContains: () => v.indexOf(this.operands[0]) === -1,\n\t\t\tbeginsWith: () => v.startsWith(this.operands[0]),\n\t\t\tbetween: () => v >= this.operands[0] && v <= this.operands[1],\n\t\t};\n\t\tconst operation = operations[this.operator as keyof typeof operations];\n\t\tif (operation) {\n\t\t\tconst result = operation();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tthrow new Error(`Invalid operator given: ${this.operator}`);\n\t\t}\n\t}\n\n\t/**\n\t * Checks `this.operands` for compatibility with `this.operator`.\n\t */\n\tvalidate(): void {\n\t\t/**\n\t\t * Creates a validator that checks for a particular `operands` count.\n\t\t * Throws an exception if the `count` disagrees with `operands.length`.\n\t\t * @param count The number of `operands` expected.\n\t\t */\n\t\tconst argumentCount = count => {\n\t\t\tconst argsClause = count === 1 ? 'argument is' : 'arguments are';\n\t\t\treturn () => {\n\t\t\t\tif (this.operands.length !== count) {\n\t\t\t\t\treturn `Exactly ${count} ${argsClause} required.`;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\t// NOTE: validations should return a message on failure.\n\t\t// hence, they should be \"joined\" together with logical OR's\n\t\t// as seen in the `between:` entry.\n\t\tconst validations = {\n\t\t\teq: argumentCount(1),\n\t\t\tne: argumentCount(1),\n\t\t\tgt: argumentCount(1),\n\t\t\tge: argumentCount(1),\n\t\t\tlt: argumentCount(1),\n\t\t\tle: argumentCount(1),\n\t\t\tcontains: argumentCount(1),\n\t\t\tnotContains: argumentCount(1),\n\t\t\tbeginsWith: argumentCount(1),\n\t\t\tbetween: () =>\n\t\t\t\targumentCount(2)() ||\n\t\t\t\t(this.operands[0] > this.operands[1]\n\t\t\t\t\t? 'The first argument must be less than or equal to the second argument.'\n\t\t\t\t\t: null),\n\t\t};\n\t\tconst validate = validations[this.operator as keyof typeof validations];\n\t\tif (validate) {\n\t\t\tconst e = validate();\n\t\t\tif (typeof e === 'string')\n\t\t\t\tthrow new Error(`Incorrect usage of \\`${this.operator}()\\`: ${e}`);\n\t\t} else {\n\t\t\tthrow new Error(`Non-existent operator: \\`${this.operator}()\\``);\n\t\t}\n\t}\n}\n\n/**\n * Small utility function to generate a monotonically increasing ID.\n * Used by GroupCondition to help keep track of which group is doing what,\n * when, and where during troubleshooting.\n */\nconst getGroupId = (() => {\n\tlet seed = 1;\n\treturn () => `group_${seed++}`;\n})();\n\n/**\n * A set of sub-conditions to operate against a model, optionally scoped to\n * a specific field, combined with the given operator (one of `and`, `or`, or `not`).\n * @member groupId Used to distinguish between GroupCondition instances for\n * debugging and troublehsooting.\n * @member model A metadata object that tells GroupCondition what to query and how.\n * @member field The field on the model that the sub-conditions apply to.\n * @member operator How to group child conditions together.\n * @member operands The child conditions.\n */\nexport class GroupCondition {\n\t// `groupId` was used for development/debugging.\n\t// Should we leave this in for future troubleshooting?\n\tpublic groupId = getGroupId();\n\n\tconstructor(\n\t\t/**\n\t\t * The `ModelMeta` of the model to query and/or filter against.\n\t\t * Expected to contain:\n\t\t *\n\t\t * ```js\n\t\t * {\n\t\t * \tbuilder: ModelConstructor,\n\t\t * \tschema: SchemaModel,\n\t\t * \tpkField: string[]\n\t\t * }\n\t\t * ```\n\t\t */\n\t\tpublic model: ModelMeta<any>,\n\n\t\t/**\n\t\t * If populated, this group specifices a condition on a relationship.\n\t\t *\n\t\t * If `field` does *not* point to a related model, that's an error. It\n\t\t * could indicate that the `GroupCondition` was instantiated with bad\n\t\t * data, or that the model metadata is incorrect.\n\t\t */\n\t\tpublic field: string | undefined,\n\n\t\t/**\n\t\t * If a `field` is given, whether the relationship is a `HAS_ONE`,\n\t\t * 'HAS_MANY`, or `BELONGS_TO`.\n\t\t *\n\t\t * TODO: Remove this and replace with derivation using\n\t\t * `ModelRelationship.from(this.model, this.field).relationship`;\n\t\t */\n\t\tpublic relationshipType: string | undefined,\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic operator: GroupOperator,\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tpublic operands: UntypedCondition[]\n\t) {}\n\n\t/**\n\t * Returns a copy of a GroupCondition, which also returns the copy of a\n\t * given reference node to \"extract\".\n\t * @param extract A node of interest. Its copy will *also* be returned if the node exists.\n\t * @returns [The full copy, the copy of `extract` | undefined]\n\t */\n\tcopy(extract: GroupCondition): [GroupCondition, GroupCondition | undefined] {\n\t\tconst copied = new GroupCondition(\n\t\t\tthis.model,\n\t\t\tthis.field,\n\t\t\tthis.relationshipType,\n\t\t\tthis.operator,\n\t\t\t[]\n\t\t);\n\n\t\tlet extractedCopy: GroupCondition | undefined =\n\t\t\textract === this ? copied : undefined;\n\n\t\tthis.operands.forEach(o => {\n\t\t\tconst [operandCopy, extractedFromOperand] = o.copy(extract);\n\t\t\tcopied.operands.push(operandCopy);\n\t\t\textractedCopy = extractedCopy || extractedFromOperand;\n\t\t});\n\n\t\treturn [copied, extractedCopy];\n\t}\n\n\t/**\n\t * Fetches matching records from a given storage adapter using legacy predicates (for now).\n\t * @param storage The storage adapter this predicate will query against.\n\t * @param breadcrumb For debugging/troubleshooting. A list of the `groupId`'s this\n\t * GroupdCondition.fetch is nested within.\n\t * @param negate Whether to match on the `NOT` of `this`.\n\t * @returns An `Promise` of `any[]` from `storage` matching the child conditions.\n\t */\n\tasync fetch(\n\t\tstorage: StorageAdapter,\n\t\tbreadcrumb: string[] = [],\n\t\tnegate = false\n\t): Promise<Record<string, any>[]> {\n\t\tconst resultGroups: Array<Record<string, any>[]> = [];\n\n\t\tconst operator = (negate ? negations[this.operator] : this.operator) as\n\t\t\t| 'or'\n\t\t\t| 'and'\n\t\t\t| 'not';\n\n\t\tconst negateChildren = negate !== (this.operator === 'not');\n\n\t\t/**\n\t\t * Conditions that must be branched out and used to generate a base, \"candidate\"\n\t\t * result set.\n\t\t *\n\t\t * If `field` is populated, these groups select *related* records, and the base,\n\t\t * candidate results are selected to match those.\n\t\t */\n\t\tconst groups = this.operands.filter(\n\t\t\top => op instanceof GroupCondition\n\t\t) as GroupCondition[];\n\n\t\t/**\n\t\t * Simple conditions that must match the target model of `this`.\n\t\t */\n\t\tconst conditions = this.operands.filter(\n\t\t\top => op instanceof FieldCondition\n\t\t) as FieldCondition[];\n\n\t\tfor (const g of groups) {\n\t\t\tconst relatives = await g.fetch(\n\t\t\t\tstorage,\n\t\t\t\t[...breadcrumb, this.groupId],\n\t\t\t\tnegateChildren\n\t\t\t);\n\n\t\t\t// no relatives -> no need to attempt to perform a \"join\" query for\n\t\t\t// candidate results:\n\t\t\t//\n\t\t\t// select a.* from a,b where b.id in EMPTY_SET ==> EMPTY_SET\n\t\t\t//\n\t\t\t// Additionally, the entire (sub)-query can be short-circuited if\n\t\t\t// the operator is `AND`. Illustrated in SQL:\n\t\t\t//\n\t\t\t// select a.* from a where\n\t\t\t//   id in [a,b,c]\n\t\t\t//     AND                        <\n\t\t\t//   id in EMTPY_SET            <<< Look!\n\t\t\t//     AND                        <\n\t\t\t//   id in [x,y,z]\n\t\t\t//\n\t\t\t// YIELDS: EMPTY_SET           // <-- Easy peasy. Lemon squeezy.\n\t\t\t//\n\t\t\tif (relatives.length === 0) {\n\t\t\t\t// aggressively short-circuit as soon as we know the group condition will fail\n\t\t\t\tif (operator === 'and') {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// less aggressive short-circuit if we know the relatives will produce no\n\t\t\t\t// candidate results; but aren't sure yet how this affects the group condition.\n\t\t\t\tresultGroups.push([]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (g.field) {\n\t\t\t\t// `relatives` are actual relatives. We'll skim them for FK query values.\n\t\t\t\t// Use the relatives to add candidate result sets (`resultGroups`)\n\n\t\t\t\tconst relationship = ModelRelationship.from(this.model, g.field);\n\n\t\t\t\tif (relationship) {\n\t\t\t\t\tconst relativesPredicates: ((\n\t\t\t\t\t\tp: RecursiveModelPredicate<any>\n\t\t\t\t\t) => RecursiveModelPredicate<any>)[] = [];\n\t\t\t\t\tfor (const relative of relatives) {\n\t\t\t\t\t\tconst individualRowJoinConditions: FieldCondition[] = [];\n\n\t\t\t\t\t\tfor (let i = 0; i < relationship.localJoinFields.length; i++) {\n\t\t\t\t\t\t\t// rightHandValue\n\t\t\t\t\t\t\tindividualRowJoinConditions.push(\n\t\t\t\t\t\t\t\tnew FieldCondition(relationship.localJoinFields[i], 'eq', [\n\t\t\t\t\t\t\t\t\trelative[relationship.remoteJoinFields[i]],\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst predicate = p =>\n\t\t\t\t\t\t\tapplyConditionsToV1Predicate(\n\t\t\t\t\t\t\t\tp,\n\t\t\t\t\t\t\t\tindividualRowJoinConditions,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\trelativesPredicates.push(predicate as any);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst predicate = FlatModelPredicateCreator.createGroupFromExisting(\n\t\t\t\t\t\tthis.model.schema,\n\t\t\t\t\t\t'or',\n\t\t\t\t\t\trelativesPredicates as any\n\t\t\t\t\t);\n\n\t\t\t\t\tresultGroups.push(\n\t\t\t\t\t\tawait storage.query(this.model.builder, predicate as any)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Missing field metadata.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// relatives are not actually relatives. they're candidate results.\n\t\t\t\tresultGroups.push(relatives);\n\t\t\t}\n\t\t}\n\n\t\t// if conditions is empty at this point, child predicates found no matches.\n\t\t// i.e., we can stop looking and return empty.\n\t\tif (conditions.length > 0) {\n\t\t\tconst predicate = FlatModelPredicateCreator.createFromExisting(\n\t\t\t\tthis.model.schema,\n\t\t\t\tp =>\n\t\t\t\t\tp[operator](c =>\n\t\t\t\t\t\tapplyConditionsToV1Predicate(c, conditions, negateChildren)\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tresultGroups.push(\n\t\t\t\tawait storage.query(this.model.builder, predicate as any)\n\t\t\t);\n\t\t} else if (conditions.length === 0 && resultGroups.length === 0) {\n\t\t\tresultGroups.push(await storage.query(this.model.builder));\n\t\t}\n\n\t\t// PK might be a single field, like `id`, or it might be several fields.\n\t\t// so, we'll need to extract the list of PK fields from an object\n\t\t// and stringify the list for easy comparison / merging.\n\t\tconst getPKValue = item =>\n\t\t\tJSON.stringify(this.model.pkField.map(name => item[name]));\n\n\t\t// will be used for intersecting or unioning results\n\t\tlet resultIndex: Map<string, Record<string, any>> | undefined;\n\n\t\tif (operator === 'and') {\n\t\t\tif (resultGroups.length === 0) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\t// for each group, we intersect, removing items from the result index\n\t\t\t// that aren't present in each subsequent group.\n\t\t\tfor (const group of resultGroups) {\n\t\t\t\tif (resultIndex === undefined) {\n\t\t\t\t\tresultIndex = new Map(group.map(item => [getPKValue(item), item]));\n\t\t\t\t} else {\n\t\t\t\t\tconst intersectWith = new Map<string, Record<string, any>>(\n\t\t\t\t\t\tgroup.map(item => [getPKValue(item), item])\n\t\t\t\t\t);\n\t\t\t\t\tfor (const k of resultIndex.keys()) {\n\t\t\t\t\t\tif (!intersectWith.has(k)) {\n\t\t\t\t\t\t\tresultIndex.delete(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (operator === 'or' || operator === 'not') {\n\t\t\t// it's OK to handle NOT here, because NOT must always only negate\n\t\t\t// a single child predicate. NOT logic will have been distributed down\n\t\t\t// to the leaf conditions already.\n\n\t\t\tresultIndex = new Map();\n\n\t\t\t// just merge the groups, performing DISTINCT-ification by ID.\n\t\t\tfor (const group of resultGroups) {\n\t\t\t\tfor (const item of group) {\n\t\t\t\t\tresultIndex.set(getPKValue(item), item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(resultIndex?.values() || []);\n\t}\n\n\t/**\n\t * Determines whether a single item matches the conditions of `this`.\n\t * When checking the target `item`'s properties, each property will be `await`'d\n\t * to ensure lazy-loading is respected where applicable.\n\t * @param item The item to match against.\n\t * @param ignoreFieldName Tells `match()` that the field name has already been dereferenced.\n\t * (Used for iterating over children on HAS_MANY checks.)\n\t * @returns A boolean (promise): `true` if matched, `false` otherwise.\n\t */\n\tasync matches(\n\t\titem: Record<string, any>,\n\t\tignoreFieldName: boolean = false\n\t): Promise<boolean> {\n\t\tconst itemToCheck =\n\t\t\tthis.field && !ignoreFieldName ? await item[this.field] : item;\n\n\t\t// if there is no item to check, we can stop recursing immediately.\n\t\t// a condition cannot match against an item that does not exist. this\n\t\t// can occur when `item.field` is optional in the schema.\n\t\tif (!itemToCheck) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (\n\t\t\tthis.relationshipType === 'HAS_MANY' &&\n\t\t\ttypeof itemToCheck[Symbol.asyncIterator] === 'function'\n\t\t) {\n\t\t\tfor await (const singleItem of itemToCheck) {\n\t\t\t\tif (await this.matches(singleItem, true)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.operator === 'or') {\n\t\t\treturn asyncSome(this.operands, c => c.matches(itemToCheck));\n\t\t} else if (this.operator === 'and') {\n\t\t\treturn asyncEvery(this.operands, c => c.matches(itemToCheck));\n\t\t} else if (this.operator === 'not') {\n\t\t\tif (this.operands.length !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Invalid arguments! `not()` accepts exactly one predicate expression.'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn !(await this.operands[0].matches(itemToCheck));\n\t\t} else {\n\t\t\tthrow new Error('Invalid group operator!');\n\t\t}\n\t}\n\n\t/**\n\t * Tranfsorm to a AppSync GraphQL compatible AST.\n\t * (Does not support filtering in nested types.)\n\t */\n\ttoAST() {\n\t\tif (this.field)\n\t\t\tthrow new Error('Nested type conditions are not supported!');\n\n\t\treturn {\n\t\t\t[this.operator]: this.operands.map(operand => operand.toAST()),\n\t\t};\n\t}\n\n\ttoStoragePredicate<T>(\n\t\tbaseCondition?: StoragePredicate<T>\n\t): StoragePredicate<T> {\n\t\treturn FlatModelPredicateCreator.createFromAST(\n\t\t\tthis.model.schema,\n\t\t\tthis.toAST()\n\t\t) as unknown as StoragePredicate<T>;\n\t}\n}\n\n/**\n * Creates a \"seed\" predicate that can be used to build an executable condition.\n * This is used in `query()`, for example, to seed customer- E.g.,\n *\n * ```\n * const p = predicateFor({builder: modelConstructor, schema: modelSchema, pkField: string[]});\n * p.and(child => [\n *   child.field.eq('whatever'),\n *   child.childModel.childField.eq('whatever else'),\n *   child.childModel.or(child => [\n *     child.otherField.contains('x'),\n *     child.otherField.contains('y'),\n *     child.otherField.contains('z'),\n *   ])\n * ])\n * ```\n *\n * `predicateFor()` returns objecst with recursive getters. To facilitate this,\n * a `query` and `tail` can be provided to \"accumulate\" nested conditions.\n *\n * TODO: the sortof-immutable algorithm was originally done to support legacy style\n * predicate branching (`p => p.x.eq(value).y.eq(value)`). i'm not sure this is\n * necessary or beneficial at this point, since we decided that each field condition\n * must flly terminate a branch. is the strong mutation barrier between chain links\n * still necessary or helpful?\n *\n * @param ModelType The ModelMeta used to build child properties.\n * @param field Scopes the query branch to a field.\n * @param query A base query to build on. Omit to start a new query.\n * @param tail The point in an existing `query` to attach new conditions to.\n * @returns A ModelPredicate (builder) that customers can create queries with.\n * (As shown in function description.)\n */\nexport function recursivePredicateFor<T extends PersistentModel>(\n\tModelType: ModelMeta<T>,\n\tallowRecursion: boolean = true,\n\tfield?: string,\n\tquery?: GroupCondition,\n\ttail?: GroupCondition\n): RecursiveModelPredicate<T> & PredicateInternalsKey {\n\t// to be used if we don't have a base query or tail to build onto\n\tconst starter = new GroupCondition(ModelType, field, undefined, 'and', []);\n\n\tconst baseCondition = query && tail ? query : starter;\n\tconst tailCondition = query && tail ? tail : starter;\n\n\t// our eventual return object, which can be built upon.\n\t// next steps will be to add or(), and(), not(), and field.op() methods.\n\tconst link = {} as any;\n\n\tregisterPredicateInternals(baseCondition, link);\n\n\tconst copyLink = () => {\n\t\tconst [query, newTail] = baseCondition.copy(tailCondition);\n\t\tconst newLink = recursivePredicateFor(\n\t\t\tModelType,\n\t\t\tallowRecursion,\n\t\t\tundefined,\n\t\t\tquery,\n\t\t\tnewTail\n\t\t);\n\t\treturn { query, newTail, newLink };\n\t};\n\n\t// Adds .or() and .and() methods to the link.\n\t// TODO: If revisiting this code, consider writing a Proxy instead.\n\t['and', 'or'].forEach(op => {\n\t\t(link as any)[op] = (\n\t\t\tbuilder: RecursiveModelPredicateAggregateExtender<T>\n\t\t) => {\n\t\t\t// or() and and() will return a copy of the original link\n\t\t\t// to head off mutability concerns.\n\t\t\tconst { query, newTail } = copyLink();\n\n\t\t\tconst childConditions = builder(\n\t\t\t\trecursivePredicateFor(ModelType, allowRecursion)\n\t\t\t);\n\t\t\tif (!Array.isArray(childConditions)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid predicate. \\`${op}\\` groups must return an array of child conditions.`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// the customer will supply a child predicate, which apply to the `model.field`\n\t\t\t// of the tail GroupCondition.\n\t\t\tnewTail?.operands.push(\n\t\t\t\tnew GroupCondition(\n\t\t\t\t\tModelType,\n\t\t\t\t\tfield,\n\t\t\t\t\tundefined,\n\t\t\t\t\top as 'and' | 'or',\n\t\t\t\t\tchildConditions.map(c => internals(c))\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// FinalPredicate\n\t\t\treturn registerPredicateInternals(query);\n\t\t};\n\t});\n\n\t// TODO: If revisiting this code, consider proxy.\n\tlink.not = (\n\t\tbuilder: RecursiveModelPredicateExtender<T>\n\t): PredicateInternalsKey => {\n\t\t// not() will return a copy of the original link\n\t\t// to head off mutability concerns.\n\t\tconst { query, newTail } = copyLink();\n\n\t\t// unlike and() and or(), the customer will supply a \"singular\" child predicate.\n\t\t// the difference being: not() does not accept an array of predicate-like objects.\n\t\t// it negates only a *single* predicate subtree.\n\t\tnewTail?.operands.push(\n\t\t\tnew GroupCondition(ModelType, field, undefined, 'not', [\n\t\t\t\tinternals(builder(recursivePredicateFor(ModelType, allowRecursion))),\n\t\t\t])\n\t\t);\n\n\t\t// A `FinalModelPredicate`.\n\t\t// Return a thing that can no longer be extended, but instead used to `async filter(items)`\n\t\t// or query storage: `.__query.fetch(storage)`.\n\t\treturn registerPredicateInternals(query);\n\t};\n\n\t// For each field on the model schema, we want to add a getter\n\t// that creates the appropriate new `link` in the query chain.\n\t// TODO: If revisiting, consider a proxy.\n\tfor (const fieldName in ModelType.schema.fields) {\n\t\tObject.defineProperty(link, fieldName, {\n\t\t\tenumerable: true,\n\t\t\tget: () => {\n\t\t\t\tconst def = ModelType.schema.fields[fieldName];\n\n\t\t\t\tif (!def.association) {\n\t\t\t\t\t// we're looking at a value field. we need to return a\n\t\t\t\t\t// \"field matcher object\", which contains all of the comparison\n\t\t\t\t\t// functions ('eq', 'ne', 'gt', etc.), scoped to operate\n\t\t\t\t\t// against the target field (fieldName).\n\t\t\t\t\treturn ops.reduce((fieldMatcher, operator) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...fieldMatcher,\n\n\t\t\t\t\t\t\t// each operator on the fieldMatcher objcect is a function.\n\t\t\t\t\t\t\t// when the customer calls the function, it returns a new link\n\t\t\t\t\t\t\t// in the chain -- for now -- this is the \"leaf\" link that\n\t\t\t\t\t\t\t// cannot be further extended.\n\t\t\t\t\t\t\t[operator]: (...operands: any[]) => {\n\t\t\t\t\t\t\t\t// build off a fresh copy of the existing `link`, just in case\n\t\t\t\t\t\t\t\t// the same link is being used elsewhere by the customer.\n\t\t\t\t\t\t\t\tconst { query, newTail } = copyLink();\n\n\t\t\t\t\t\t\t\t// add the given condition to the link's TAIL node.\n\t\t\t\t\t\t\t\t// remember: the base link might go N nodes deep! e.g.,\n\t\t\t\t\t\t\t\tnewTail?.operands.push(\n\t\t\t\t\t\t\t\t\tnew FieldCondition(fieldName, operator, operands)\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t// A `FinalModelPredicate`.\n\t\t\t\t\t\t\t\t// Return a thing that can no longer be extended, but instead used to `async filter(items)`\n\t\t\t\t\t\t\t\t// or query storage: `.__query.fetch(storage)`.\n\t\t\t\t\t\t\t\treturn registerPredicateInternals(query);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\t\t\t\t\t}, {});\n\t\t\t\t} else {\n\t\t\t\t\tif (!allowRecursion) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Predication on releated models is not supported in this context.'\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tdef.association.connectionType === 'BELONGS_TO' ||\n\t\t\t\t\t\tdef.association.connectionType === 'HAS_ONE' ||\n\t\t\t\t\t\tdef.association.connectionType === 'HAS_MANY'\n\t\t\t\t\t) {\n\t\t\t\t\t\t// the use has just typed '.someRelatedModel'. we need to given them\n\t\t\t\t\t\t// back a predicate chain.\n\n\t\t\t\t\t\tconst relatedMeta = (def.type as ModelFieldType).modelConstructor;\n\t\t\t\t\t\tif (!relatedMeta) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t'Related model metadata is missing. This is a bug! Please report it.'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `Model.reletedModelField` returns a copy of the original link,\n\t\t\t\t\t\t// and will contains copies of internal GroupConditions\n\t\t\t\t\t\t// to head off mutability concerns.\n\t\t\t\t\t\tconst [newquery, oldtail] = baseCondition.copy(tailCondition);\n\t\t\t\t\t\tconst newtail = new GroupCondition(\n\t\t\t\t\t\t\trelatedMeta,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\tdef.association.connectionType,\n\t\t\t\t\t\t\t'and',\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// `oldtail` here refers to the *copy* of the old tail.\n\t\t\t\t\t\t// so, it's safe to modify at this point. and we need to modify\n\t\t\t\t\t\t// it to push the *new* tail onto the end of it.\n\t\t\t\t\t\t(oldtail as GroupCondition).operands.push(newtail);\n\t\t\t\t\t\tconst newlink = recursivePredicateFor(\n\t\t\t\t\t\t\trelatedMeta,\n\t\t\t\t\t\t\tallowRecursion,\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\tnewquery,\n\t\t\t\t\t\t\tnewtail\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn newlink;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Related model definition doesn't have a typedef. This is a bug! Please report it.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n\n\treturn link;\n}\n\nexport function predicateFor<T extends PersistentModel>(\n\tModelType: ModelMeta<T>\n): ModelPredicate<T> & PredicateInternalsKey {\n\treturn recursivePredicateFor(ModelType, false) as any as ModelPredicate<T>;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}