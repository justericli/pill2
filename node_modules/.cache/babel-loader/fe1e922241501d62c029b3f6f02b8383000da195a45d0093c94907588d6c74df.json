{"ast":null,"code":"import _regeneratorRuntime from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nexport var DefaultRateLimiter = /*#__PURE__*/function () {\n  function DefaultRateLimiter(options) {\n    var _options$beta, _options$minCapacity, _options$minFillRate, _options$scaleConstan, _options$smooth;\n    _classCallCheck(this, DefaultRateLimiter);\n    this.currentCapacity = 0;\n    this.enabled = false;\n    this.lastMaxRate = 0;\n    this.measuredTxRate = 0;\n    this.requestCount = 0;\n    this.lastTimestamp = 0;\n    this.timeWindow = 0;\n    this.beta = (_options$beta = options === null || options === void 0 ? void 0 : options.beta) !== null && _options$beta !== void 0 ? _options$beta : 0.7;\n    this.minCapacity = (_options$minCapacity = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _options$minCapacity !== void 0 ? _options$minCapacity : 1;\n    this.minFillRate = (_options$minFillRate = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _options$minFillRate !== void 0 ? _options$minFillRate : 0.5;\n    this.scaleConstant = (_options$scaleConstan = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _options$scaleConstan !== void 0 ? _options$scaleConstan : 0.4;\n    this.smooth = (_options$smooth = options === null || options === void 0 ? void 0 : options.smooth) !== null && _options$smooth !== void 0 ? _options$smooth : 0.8;\n    var currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n  _createClass(DefaultRateLimiter, [{\n    key: \"getCurrentTimeInSeconds\",\n    value: function getCurrentTimeInSeconds() {\n      return Date.now() / 1000;\n    }\n  }, {\n    key: \"getSendToken\",\n    value: function () {\n      var _getSendToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.acquireTokenBucket(1));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function getSendToken() {\n        return _getSendToken.apply(this, arguments);\n      }\n      return getSendToken;\n    }()\n  }, {\n    key: \"acquireTokenBucket\",\n    value: function () {\n      var _acquireTokenBucket = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(amount) {\n        var delay;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.enabled) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              this.refillTokenBucket();\n              if (!(amount > this.currentCapacity)) {\n                _context2.next = 7;\n                break;\n              }\n              delay = (amount - this.currentCapacity) / this.fillRate * 1000;\n              _context2.next = 7;\n              return new Promise(function (resolve) {\n                return setTimeout(resolve, delay);\n              });\n            case 7:\n              this.currentCapacity = this.currentCapacity - amount;\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function acquireTokenBucket(_x) {\n        return _acquireTokenBucket.apply(this, arguments);\n      }\n      return acquireTokenBucket;\n    }()\n  }, {\n    key: \"refillTokenBucket\",\n    value: function refillTokenBucket() {\n      var timestamp = this.getCurrentTimeInSeconds();\n      if (!this.lastTimestamp) {\n        this.lastTimestamp = timestamp;\n        return;\n      }\n      var fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n      this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n      this.lastTimestamp = timestamp;\n    }\n  }, {\n    key: \"updateClientSendingRate\",\n    value: function updateClientSendingRate(response) {\n      var calculatedRate;\n      this.updateMeasuredRate();\n      if (isThrottlingError(response)) {\n        var rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n        this.lastMaxRate = rateToUse;\n        this.calculateTimeWindow();\n        this.lastThrottleTime = this.getCurrentTimeInSeconds();\n        calculatedRate = this.cubicThrottle(rateToUse);\n        this.enableTokenBucket();\n      } else {\n        this.calculateTimeWindow();\n        calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n      }\n      var newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n      this.updateTokenBucketRate(newRate);\n    }\n  }, {\n    key: \"calculateTimeWindow\",\n    value: function calculateTimeWindow() {\n      this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));\n    }\n  }, {\n    key: \"cubicThrottle\",\n    value: function cubicThrottle(rateToUse) {\n      return this.getPrecise(rateToUse * this.beta);\n    }\n  }, {\n    key: \"cubicSuccess\",\n    value: function cubicSuccess(timestamp) {\n      return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n    }\n  }, {\n    key: \"enableTokenBucket\",\n    value: function enableTokenBucket() {\n      this.enabled = true;\n    }\n  }, {\n    key: \"updateTokenBucketRate\",\n    value: function updateTokenBucketRate(newRate) {\n      this.refillTokenBucket();\n      this.fillRate = Math.max(newRate, this.minFillRate);\n      this.maxCapacity = Math.max(newRate, this.minCapacity);\n      this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n    }\n  }, {\n    key: \"updateMeasuredRate\",\n    value: function updateMeasuredRate() {\n      var t = this.getCurrentTimeInSeconds();\n      var timeBucket = Math.floor(t * 2) / 2;\n      this.requestCount++;\n      if (timeBucket > this.lastTxRateBucket) {\n        var currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n        this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n        this.requestCount = 0;\n        this.lastTxRateBucket = timeBucket;\n      }\n    }\n  }, {\n    key: \"getPrecise\",\n    value: function getPrecise(num) {\n      return parseFloat(num.toFixed(8));\n    }\n  }]);\n  return DefaultRateLimiter;\n}();","map":{"version":3,"names":["isThrottlingError","DefaultRateLimiter","options","_options$beta","_options$minCapacity","_options$minFillRate","_options$scaleConstan","_options$smooth","_classCallCheck","currentCapacity","enabled","lastMaxRate","measuredTxRate","requestCount","lastTimestamp","timeWindow","beta","minCapacity","minFillRate","scaleConstant","smooth","currentTimeInSeconds","getCurrentTimeInSeconds","lastThrottleTime","lastTxRateBucket","Math","floor","fillRate","maxCapacity","_createClass","key","value","Date","now","_getSendToken","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","acquireTokenBucket","stop","getSendToken","apply","arguments","_acquireTokenBucket","_callee2","amount","delay","_callee2$","_context2","refillTokenBucket","Promise","resolve","setTimeout","_x","timestamp","fillAmount","min","updateClientSendingRate","response","calculatedRate","updateMeasuredRate","rateToUse","calculateTimeWindow","cubicThrottle","enableTokenBucket","cubicSuccess","newRate","updateTokenBucketRate","getPrecise","pow","max","t","timeBucket","currentRate","num","parseFloat","toFixed"],"sources":["/Users/ericli/Desktop/pill2/node_modules/@aws-sdk/util-retry/dist-es/DefaultRateLimiter.js"],"sourcesContent":["import { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nexport class DefaultRateLimiter {\n    constructor(options) {\n        this.currentCapacity = 0;\n        this.enabled = false;\n        this.lastMaxRate = 0;\n        this.measuredTxRate = 0;\n        this.requestCount = 0;\n        this.lastTimestamp = 0;\n        this.timeWindow = 0;\n        this.beta = options?.beta ?? 0.7;\n        this.minCapacity = options?.minCapacity ?? 1;\n        this.minFillRate = options?.minFillRate ?? 0.5;\n        this.scaleConstant = options?.scaleConstant ?? 0.4;\n        this.smooth = options?.smooth ?? 0.8;\n        const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n        this.lastThrottleTime = currentTimeInSeconds;\n        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n        this.fillRate = this.minFillRate;\n        this.maxCapacity = this.minCapacity;\n    }\n    getCurrentTimeInSeconds() {\n        return Date.now() / 1000;\n    }\n    async getSendToken() {\n        return this.acquireTokenBucket(1);\n    }\n    async acquireTokenBucket(amount) {\n        if (!this.enabled) {\n            return;\n        }\n        this.refillTokenBucket();\n        if (amount > this.currentCapacity) {\n            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n        this.currentCapacity = this.currentCapacity - amount;\n    }\n    refillTokenBucket() {\n        const timestamp = this.getCurrentTimeInSeconds();\n        if (!this.lastTimestamp) {\n            this.lastTimestamp = timestamp;\n            return;\n        }\n        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n        this.lastTimestamp = timestamp;\n    }\n    updateClientSendingRate(response) {\n        let calculatedRate;\n        this.updateMeasuredRate();\n        if (isThrottlingError(response)) {\n            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n            this.lastMaxRate = rateToUse;\n            this.calculateTimeWindow();\n            this.lastThrottleTime = this.getCurrentTimeInSeconds();\n            calculatedRate = this.cubicThrottle(rateToUse);\n            this.enableTokenBucket();\n        }\n        else {\n            this.calculateTimeWindow();\n            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n        }\n        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n        this.updateTokenBucketRate(newRate);\n    }\n    calculateTimeWindow() {\n        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));\n    }\n    cubicThrottle(rateToUse) {\n        return this.getPrecise(rateToUse * this.beta);\n    }\n    cubicSuccess(timestamp) {\n        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n    }\n    enableTokenBucket() {\n        this.enabled = true;\n    }\n    updateTokenBucketRate(newRate) {\n        this.refillTokenBucket();\n        this.fillRate = Math.max(newRate, this.minFillRate);\n        this.maxCapacity = Math.max(newRate, this.minCapacity);\n        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n    }\n    updateMeasuredRate() {\n        const t = this.getCurrentTimeInSeconds();\n        const timeBucket = Math.floor(t * 2) / 2;\n        this.requestCount++;\n        if (timeBucket > this.lastTxRateBucket) {\n            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n            this.requestCount = 0;\n            this.lastTxRateBucket = timeBucket;\n        }\n    }\n    getPrecise(num) {\n        return parseFloat(num.toFixed(8));\n    }\n}\n"],"mappings":";;;;AAAA,SAASA,iBAAiB,QAAQ,uCAAuC;AACzE,WAAaC,kBAAkB;EAC3B,SAAAA,mBAAYC,OAAO,EAAE;IAAA,IAAAC,aAAA,EAAAC,oBAAA,EAAAC,oBAAA,EAAAC,qBAAA,EAAAC,eAAA;IAAAC,eAAA,OAAAP,kBAAA;IACjB,IAAI,CAACQ,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,WAAW,GAAG,CAAC;IACpB,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,aAAa,GAAG,CAAC;IACtB,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,IAAI,IAAAb,aAAA,GAAGD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEc,IAAI,cAAAb,aAAA,cAAAA,aAAA,GAAI,GAAG;IAChC,IAAI,CAACc,WAAW,IAAAb,oBAAA,GAAGF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEe,WAAW,cAAAb,oBAAA,cAAAA,oBAAA,GAAI,CAAC;IAC5C,IAAI,CAACc,WAAW,IAAAb,oBAAA,GAAGH,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEgB,WAAW,cAAAb,oBAAA,cAAAA,oBAAA,GAAI,GAAG;IAC9C,IAAI,CAACc,aAAa,IAAAb,qBAAA,GAAGJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEiB,aAAa,cAAAb,qBAAA,cAAAA,qBAAA,GAAI,GAAG;IAClD,IAAI,CAACc,MAAM,IAAAb,eAAA,GAAGL,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEkB,MAAM,cAAAb,eAAA,cAAAA,eAAA,GAAI,GAAG;IACpC,IAAMc,oBAAoB,GAAG,IAAI,CAACC,uBAAuB,EAAE;IAC3D,IAAI,CAACC,gBAAgB,GAAGF,oBAAoB;IAC5C,IAAI,CAACG,gBAAgB,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACJ,uBAAuB,EAAE,CAAC;IAClE,IAAI,CAACK,QAAQ,GAAG,IAAI,CAACT,WAAW;IAChC,IAAI,CAACU,WAAW,GAAG,IAAI,CAACX,WAAW;EACvC;EAACY,YAAA,CAAA5B,kBAAA;IAAA6B,GAAA;IAAAC,KAAA,EACD,SAAAT,wBAAA,EAA0B;MACtB,OAAOU,IAAI,CAACC,GAAG,EAAE,GAAG,IAAI;IAC5B;EAAC;IAAAH,GAAA;IAAAC,KAAA;MAAA,IAAAG,aAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CACD,SAAAC,QAAA;QAAA,OAAAF,mBAAA,GAAAG,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;YAAA;cAAA,OAAAF,QAAA,CAAAG,MAAA,WACW,IAAI,CAACC,kBAAkB,CAAC,CAAC,CAAC;YAAA;YAAA;cAAA,OAAAJ,QAAA,CAAAK,IAAA;UAAA;QAAA,GAAAR,OAAA;MAAA,CACpC;MAAA,SAAAS,aAAA;QAAA,OAAAb,aAAA,CAAAc,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAF,YAAA;IAAA;EAAA;IAAAjB,GAAA;IAAAC,KAAA;MAAA,IAAAmB,mBAAA,GAAAf,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CACD,SAAAc,SAAyBC,MAAM;QAAA,IAAAC,KAAA;QAAA,OAAAjB,mBAAA,GAAAG,IAAA,UAAAe,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAb,IAAA,GAAAa,SAAA,CAAAZ,IAAA;YAAA;cAAA,IACtB,IAAI,CAACjC,OAAO;gBAAA6C,SAAA,CAAAZ,IAAA;gBAAA;cAAA;cAAA,OAAAY,SAAA,CAAAX,MAAA;YAAA;cAGjB,IAAI,CAACY,iBAAiB,EAAE;cAAC,MACrBJ,MAAM,GAAG,IAAI,CAAC3C,eAAe;gBAAA8C,SAAA,CAAAZ,IAAA;gBAAA;cAAA;cACvBU,KAAK,GAAI,CAACD,MAAM,GAAG,IAAI,CAAC3C,eAAe,IAAI,IAAI,CAACkB,QAAQ,GAAI,IAAI;cAAA4B,SAAA,CAAAZ,IAAA;cAAA,OAChE,IAAIc,OAAO,CAAC,UAACC,OAAO;gBAAA,OAAKC,UAAU,CAACD,OAAO,EAAEL,KAAK,CAAC;cAAA,EAAC;YAAA;cAE9D,IAAI,CAAC5C,eAAe,GAAG,IAAI,CAACA,eAAe,GAAG2C,MAAM;YAAC;YAAA;cAAA,OAAAG,SAAA,CAAAT,IAAA;UAAA;QAAA,GAAAK,QAAA;MAAA,CACxD;MAAA,SAAAN,mBAAAe,EAAA;QAAA,OAAAV,mBAAA,CAAAF,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAJ,kBAAA;IAAA;EAAA;IAAAf,GAAA;IAAAC,KAAA,EACD,SAAAyB,kBAAA,EAAoB;MAChB,IAAMK,SAAS,GAAG,IAAI,CAACvC,uBAAuB,EAAE;MAChD,IAAI,CAAC,IAAI,CAACR,aAAa,EAAE;QACrB,IAAI,CAACA,aAAa,GAAG+C,SAAS;QAC9B;MACJ;MACA,IAAMC,UAAU,GAAG,CAACD,SAAS,GAAG,IAAI,CAAC/C,aAAa,IAAI,IAAI,CAACa,QAAQ;MACnE,IAAI,CAAClB,eAAe,GAAGgB,IAAI,CAACsC,GAAG,CAAC,IAAI,CAACnC,WAAW,EAAE,IAAI,CAACnB,eAAe,GAAGqD,UAAU,CAAC;MACpF,IAAI,CAAChD,aAAa,GAAG+C,SAAS;IAClC;EAAC;IAAA/B,GAAA;IAAAC,KAAA,EACD,SAAAiC,wBAAwBC,QAAQ,EAAE;MAC9B,IAAIC,cAAc;MAClB,IAAI,CAACC,kBAAkB,EAAE;MACzB,IAAInE,iBAAiB,CAACiE,QAAQ,CAAC,EAAE;QAC7B,IAAMG,SAAS,GAAG,CAAC,IAAI,CAAC1D,OAAO,GAAG,IAAI,CAACE,cAAc,GAAGa,IAAI,CAACsC,GAAG,CAAC,IAAI,CAACnD,cAAc,EAAE,IAAI,CAACe,QAAQ,CAAC;QACpG,IAAI,CAAChB,WAAW,GAAGyD,SAAS;QAC5B,IAAI,CAACC,mBAAmB,EAAE;QAC1B,IAAI,CAAC9C,gBAAgB,GAAG,IAAI,CAACD,uBAAuB,EAAE;QACtD4C,cAAc,GAAG,IAAI,CAACI,aAAa,CAACF,SAAS,CAAC;QAC9C,IAAI,CAACG,iBAAiB,EAAE;MAC5B,CAAC,MACI;QACD,IAAI,CAACF,mBAAmB,EAAE;QAC1BH,cAAc,GAAG,IAAI,CAACM,YAAY,CAAC,IAAI,CAAClD,uBAAuB,EAAE,CAAC;MACtE;MACA,IAAMmD,OAAO,GAAGhD,IAAI,CAACsC,GAAG,CAACG,cAAc,EAAE,CAAC,GAAG,IAAI,CAACtD,cAAc,CAAC;MACjE,IAAI,CAAC8D,qBAAqB,CAACD,OAAO,CAAC;IACvC;EAAC;IAAA3C,GAAA;IAAAC,KAAA,EACD,SAAAsC,oBAAA,EAAsB;MAClB,IAAI,CAACtD,UAAU,GAAG,IAAI,CAAC4D,UAAU,CAAClD,IAAI,CAACmD,GAAG,CAAE,IAAI,CAACjE,WAAW,IAAI,CAAC,GAAG,IAAI,CAACK,IAAI,CAAC,GAAI,IAAI,CAACG,aAAa,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;IACjH;EAAC;IAAAW,GAAA;IAAAC,KAAA,EACD,SAAAuC,cAAcF,SAAS,EAAE;MACrB,OAAO,IAAI,CAACO,UAAU,CAACP,SAAS,GAAG,IAAI,CAACpD,IAAI,CAAC;IACjD;EAAC;IAAAc,GAAA;IAAAC,KAAA,EACD,SAAAyC,aAAaX,SAAS,EAAE;MACpB,OAAO,IAAI,CAACc,UAAU,CAAC,IAAI,CAACxD,aAAa,GAAGM,IAAI,CAACmD,GAAG,CAACf,SAAS,GAAG,IAAI,CAACtC,gBAAgB,GAAG,IAAI,CAACR,UAAU,EAAE,CAAC,CAAC,GAAG,IAAI,CAACJ,WAAW,CAAC;IACpI;EAAC;IAAAmB,GAAA;IAAAC,KAAA,EACD,SAAAwC,kBAAA,EAAoB;MAChB,IAAI,CAAC7D,OAAO,GAAG,IAAI;IACvB;EAAC;IAAAoB,GAAA;IAAAC,KAAA,EACD,SAAA2C,sBAAsBD,OAAO,EAAE;MAC3B,IAAI,CAACjB,iBAAiB,EAAE;MACxB,IAAI,CAAC7B,QAAQ,GAAGF,IAAI,CAACoD,GAAG,CAACJ,OAAO,EAAE,IAAI,CAACvD,WAAW,CAAC;MACnD,IAAI,CAACU,WAAW,GAAGH,IAAI,CAACoD,GAAG,CAACJ,OAAO,EAAE,IAAI,CAACxD,WAAW,CAAC;MACtD,IAAI,CAACR,eAAe,GAAGgB,IAAI,CAACsC,GAAG,CAAC,IAAI,CAACtD,eAAe,EAAE,IAAI,CAACmB,WAAW,CAAC;IAC3E;EAAC;IAAAE,GAAA;IAAAC,KAAA,EACD,SAAAoC,mBAAA,EAAqB;MACjB,IAAMW,CAAC,GAAG,IAAI,CAACxD,uBAAuB,EAAE;MACxC,IAAMyD,UAAU,GAAGtD,IAAI,CAACC,KAAK,CAACoD,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;MACxC,IAAI,CAACjE,YAAY,EAAE;MACnB,IAAIkE,UAAU,GAAG,IAAI,CAACvD,gBAAgB,EAAE;QACpC,IAAMwD,WAAW,GAAG,IAAI,CAACnE,YAAY,IAAIkE,UAAU,GAAG,IAAI,CAACvD,gBAAgB,CAAC;QAC5E,IAAI,CAACZ,cAAc,GAAG,IAAI,CAAC+D,UAAU,CAACK,WAAW,GAAG,IAAI,CAAC5D,MAAM,GAAG,IAAI,CAACR,cAAc,IAAI,CAAC,GAAG,IAAI,CAACQ,MAAM,CAAC,CAAC;QAC1G,IAAI,CAACP,YAAY,GAAG,CAAC;QACrB,IAAI,CAACW,gBAAgB,GAAGuD,UAAU;MACtC;IACJ;EAAC;IAAAjD,GAAA;IAAAC,KAAA,EACD,SAAA4C,WAAWM,GAAG,EAAE;MACZ,OAAOC,UAAU,CAACD,GAAG,CAACE,OAAO,CAAC,CAAC,CAAC,CAAC;IACrC;EAAC;EAAA,OAAAlF,kBAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}