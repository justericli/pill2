{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { EndpointError } from \"../types\";\nimport { evaluateEndpointRule } from \"./evaluateEndpointRule\";\nimport { evaluateErrorRule } from \"./evaluateErrorRule\";\nimport { evaluateTreeRule } from \"./evaluateTreeRule\";\nexport var evaluateRules = function evaluateRules(rules, options) {\n  var _iterator = _createForOfIteratorHelper(rules),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var rule = _step.value;\n      if (rule.type === \"endpoint\") {\n        var endpointOrUndefined = evaluateEndpointRule(rule, options);\n        if (endpointOrUndefined) {\n          return endpointOrUndefined;\n        }\n      } else if (rule.type === \"error\") {\n        evaluateErrorRule(rule, options);\n      } else if (rule.type === \"tree\") {\n        var _endpointOrUndefined = evaluateTreeRule(rule, options);\n        if (_endpointOrUndefined) {\n          return _endpointOrUndefined;\n        }\n      } else {\n        throw new EndpointError(\"Unknown endpoint rule: \".concat(rule));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  throw new EndpointError(\"Rules evaluation failed\");\n};","map":{"version":3,"names":["EndpointError","evaluateEndpointRule","evaluateErrorRule","evaluateTreeRule","evaluateRules","rules","options","_iterator","_createForOfIteratorHelper","_step","s","n","done","rule","value","type","endpointOrUndefined","concat","err","e","f"],"sources":["/Users/ericli/Desktop/pill2/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateRules.js"],"sourcesContent":["import { EndpointError } from \"../types\";\nimport { evaluateEndpointRule } from \"./evaluateEndpointRule\";\nimport { evaluateErrorRule } from \"./evaluateErrorRule\";\nimport { evaluateTreeRule } from \"./evaluateTreeRule\";\nexport const evaluateRules = (rules, options) => {\n    for (const rule of rules) {\n        if (rule.type === \"endpoint\") {\n            const endpointOrUndefined = evaluateEndpointRule(rule, options);\n            if (endpointOrUndefined) {\n                return endpointOrUndefined;\n            }\n        }\n        else if (rule.type === \"error\") {\n            evaluateErrorRule(rule, options);\n        }\n        else if (rule.type === \"tree\") {\n            const endpointOrUndefined = evaluateTreeRule(rule, options);\n            if (endpointOrUndefined) {\n                return endpointOrUndefined;\n            }\n        }\n        else {\n            throw new EndpointError(`Unknown endpoint rule: ${rule}`);\n        }\n    }\n    throw new EndpointError(`Rules evaluation failed`);\n};\n"],"mappings":";AAAA,SAASA,aAAa,QAAQ,UAAU;AACxC,SAASC,oBAAoB,QAAQ,wBAAwB;AAC7D,SAASC,iBAAiB,QAAQ,qBAAqB;AACvD,SAASC,gBAAgB,QAAQ,oBAAoB;AACrD,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAIC,KAAK,EAAEC,OAAO,EAAK;EAAA,IAAAC,SAAA,GAAAC,0BAAA,CAC1BH,KAAK;IAAAI,KAAA;EAAA;IAAxB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA0B;MAAA,IAAfC,IAAI,GAAAJ,KAAA,CAAAK,KAAA;MACX,IAAID,IAAI,CAACE,IAAI,KAAK,UAAU,EAAE;QAC1B,IAAMC,mBAAmB,GAAGf,oBAAoB,CAACY,IAAI,EAAEP,OAAO,CAAC;QAC/D,IAAIU,mBAAmB,EAAE;UACrB,OAAOA,mBAAmB;QAC9B;MACJ,CAAC,MACI,IAAIH,IAAI,CAACE,IAAI,KAAK,OAAO,EAAE;QAC5Bb,iBAAiB,CAACW,IAAI,EAAEP,OAAO,CAAC;MACpC,CAAC,MACI,IAAIO,IAAI,CAACE,IAAI,KAAK,MAAM,EAAE;QAC3B,IAAMC,oBAAmB,GAAGb,gBAAgB,CAACU,IAAI,EAAEP,OAAO,CAAC;QAC3D,IAAIU,oBAAmB,EAAE;UACrB,OAAOA,oBAAmB;QAC9B;MACJ,CAAC,MACI;QACD,MAAM,IAAIhB,aAAa,2BAAAiB,MAAA,CAA2BJ,IAAI,EAAG;MAC7D;IACJ;EAAC,SAAAK,GAAA;IAAAX,SAAA,CAAAY,CAAA,CAAAD,GAAA;EAAA;IAAAX,SAAA,CAAAa,CAAA;EAAA;EACD,MAAM,IAAIpB,aAAa,2BAA2B;AACtD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}