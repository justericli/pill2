{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { ClientDevice, Credentials, getAmplifyUserAgent, StorageHelper, transferKeyToUpperCase } from '@aws-amplify/core';\nimport { Cache } from '@aws-amplify/cache';\nimport { ChannelType, GetInAppMessagesCommand, UpdateEndpointCommand, PinpointClient } from '@aws-sdk/client-pinpoint';\nimport { v4 as uuid } from 'uuid';\nimport { addMessageInteractionEventListener } from '../../eventListeners';\nimport SessionTracker from '../../SessionTracker';\nimport { InAppMessageInteractionEvent } from '../../types';\nimport { AWSPinpointMessageEvent } from './types';\nimport { clearMemo, dispatchInAppMessagingEvent, extractContent, extractMetadata, getStartOfDay, interpretLayout, isBeforeEndDate, logger, matchesAttributes, matchesEventType, matchesMetrics, recordAnalyticsEvent } from './utils';\nvar MESSAGE_DAILY_COUNT_KEY = 'pinpointProvider_inAppMessages_dailyCount';\nvar MESSAGE_TOTAL_COUNT_KEY = 'pinpointProvider_inAppMessages_totalCount';\nvar AWSPinpointProvider = /** @class */function () {\n  function AWSPinpointProvider() {\n    var _this = this;\n    var _a;\n    this.config = {};\n    this.configured = false;\n    this.endpointInitialized = false;\n    this.initialized = false;\n    this.configure = function (config) {\n      if (config === void 0) {\n        config = {};\n      }\n      _this.config = __assign(__assign({}, _this.config), config);\n      logger.debug('configure AWSPinpointProvider', _this.config);\n      // some configuration steps should not be re-run even if provider is re-configured for some reason\n      if (!_this.configured) {\n        _this.sessionTracker = new SessionTracker(_this.sessionStateChangeHandler);\n        _this.sessionTracker.start();\n        // wire up default Pinpoint message event handling\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_DISPLAYED);\n        }, InAppMessageInteractionEvent.MESSAGE_DISPLAYED);\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_DISMISSED);\n        }, InAppMessageInteractionEvent.MESSAGE_DISMISSED);\n        addMessageInteractionEventListener(function (message) {\n          _this.recordMessageEvent(message, AWSPinpointMessageEvent.MESSAGE_ACTION_TAKEN);\n        }, InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN);\n      }\n      _this.configured = true;\n      dispatchInAppMessagingEvent('pinpointProvider_configured', null);\n      return _this.config;\n    };\n    this.getInAppMessages = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, endpointId, pinpointClient, input, command, response, messages, err_1;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _b.sent();\n              _b.label = 2;\n            case 2:\n              // There is no way to granuarly reconcile the filter memoization as the keys are composited from a message id and\n              // event properties thus opting to just clear them out when getting messages rather than leave potentially\n              // obsolete entries that will no longer serve any purpose.\n              clearMemo();\n              _b.label = 3;\n            case 3:\n              _b.trys.push([3, 6,, 7]);\n              return [4 /*yield*/, this.updateEndpoint()];\n            case 4:\n              _b.sent();\n              _a = this.config, appId = _a.appId, endpointId = _a.endpointId, pinpointClient = _a.pinpointClient;\n              input = {\n                ApplicationId: appId,\n                EndpointId: endpointId\n              };\n              command = new GetInAppMessagesCommand(input);\n              logger.debug('getting in-app messages', input);\n              return [4 /*yield*/, pinpointClient.send(command)];\n            case 5:\n              response = _b.sent();\n              messages = response.InAppMessagesResponse.InAppMessageCampaigns;\n              dispatchInAppMessagingEvent('getInAppMessages', messages);\n              return [2 /*return*/, messages];\n            case 6:\n              err_1 = _b.sent();\n              logger.error('Error getting in-app messages', err_1);\n              throw err_1;\n            case 7:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.processInAppMessages = function (messages, event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var highestPrioritySeen;\n        var _this = this;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              return [2 /*return*/, this.normalizeMessages(messages.reduce(function (acc, message) {\n                var messageQualifies = matchesEventType(message, event) && matchesAttributes(message, event) && matchesMetrics(message, event) && isBeforeEndDate(message) && _this.isBelowCap(message);\n                // filter all qualifying messages returning only those that are of (relative) highest priority\n                if (messageQualifies) {\n                  // have not yet encountered message with priority\n                  if (!highestPrioritySeen) {\n                    // this message has priority, so reset the accumulator with this message only\n                    if (message.Priority) {\n                      highestPrioritySeen = message.Priority;\n                      return [message];\n                    } else {\n                      // this message also has no priority, so just add this message to accumulator\n                      acc.push(message);\n                    }\n                    // have previously encountered message with priority, so only messages with priority matter now\n                  } else if (message.Priority) {\n                    // this message has higher priority (lower number), so reset the accumulator with this message only\n                    if (message.Priority < highestPrioritySeen) {\n                      highestPrioritySeen = message.Priority;\n                      return [message];\n                      // this message has the same priority, so just add this message to accumulator\n                    } else if (message.Priority === highestPrioritySeen) {\n                      acc.push(message);\n                    }\n                  }\n                }\n                return acc;\n              }, []))];\n          }\n        });\n      });\n    };\n    this.identifyUser = function (userId, userInfo) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var err_2;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              _a.trys.push([2, 4,, 5]);\n              return [4 /*yield*/, this.updateEndpoint(userId, userInfo)];\n            case 3:\n              _a.sent();\n              return [3 /*break*/, 5];\n            case 4:\n              err_2 = _a.sent();\n              logger.error('Error identifying user', err_2);\n              throw err_2;\n            case 5:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.init = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, endpointId, storage, providerName, _b, err_3;\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              _a = this.config, endpointId = _a.endpointId, storage = _a.storage;\n              providerName = this.getProviderName();\n              _c.label = 1;\n            case 1:\n              _c.trys.push([1, 6,, 7]);\n              if (!(typeof storage.sync === 'function')) return [3 /*break*/, 3];\n              return [4 /*yield*/, storage.sync()];\n            case 2:\n              _c.sent();\n              _c.label = 3;\n            case 3:\n              if (!!endpointId) return [3 /*break*/, 5];\n              _b = this.config;\n              return [4 /*yield*/, this.getEndpointId()];\n            case 4:\n              _b.endpointId = _c.sent();\n              _c.label = 5;\n            case 5:\n              this.initialized = true;\n              return [3 /*break*/, 7];\n            case 6:\n              err_3 = _c.sent();\n              logger.error(\"Failed to initialize \" + providerName, err_3);\n              return [3 /*break*/, 7];\n            case 7:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.initPinpointClient = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, credentials, pinpointClient, region;\n        return __generator(this, function (_b) {\n          _a = this.config, appId = _a.appId, credentials = _a.credentials, pinpointClient = _a.pinpointClient, region = _a.region;\n          if (!appId || !credentials || !region) {\n            throw new Error('One or more of credentials, appId or region is not configured');\n          }\n          if (pinpointClient) {\n            pinpointClient.destroy();\n          }\n          this.config.pinpointClient = new PinpointClient({\n            region: region,\n            credentials: credentials,\n            customUserAgent: getAmplifyUserAgent()\n          });\n          return [2 /*return*/];\n        });\n      });\n    };\n\n    this.getEndpointId = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var appId, cacheKey, cachedEndpointId, endpointId, ttl, expiration;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              appId = this.config.appId;\n              cacheKey = this.getSubCategory() + \":\" + this.getProviderName() + \":\" + appId;\n              return [4 /*yield*/, Cache.getItem(cacheKey)];\n            case 1:\n              cachedEndpointId = _a.sent();\n              // Found in cache, just return it\n              if (cachedEndpointId) {\n                return [2 /*return*/, cachedEndpointId];\n              }\n              endpointId = uuid();\n              ttl = 1000 * 60 * 60 * 24 * 365 * 100;\n              expiration = new Date().getTime() + ttl;\n              Cache.setItem(cacheKey, endpointId, {\n                expires: expiration,\n                priority: 1\n              });\n              return [2 /*return*/, endpointId];\n          }\n        });\n      });\n    };\n    this.updateEndpoint = function (userId, userInfo) {\n      if (userId === void 0) {\n        userId = null;\n      }\n      if (userInfo === void 0) {\n        userInfo = null;\n      }\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, appId, credentials, endpointId, _b, endpointInfo, pinpointClient, currentCredentials, credentialsUpdated, _c, address, attributes, demographic, location_1, metrics, optOut, _d, appVersion, make, model, platform, version, input, command, err_4;\n        var _e;\n        return __generator(this, function (_f) {\n          switch (_f.label) {\n            case 0:\n              _a = this.config, appId = _a.appId, credentials = _a.credentials, endpointId = _a.endpointId, _b = _a.endpointInfo, endpointInfo = _b === void 0 ? {} : _b, pinpointClient = _a.pinpointClient;\n              return [4 /*yield*/, this.getCredentials()];\n            case 1:\n              currentCredentials = _f.sent();\n              credentialsUpdated = !credentials || Object.keys(currentCredentials).some(function (key) {\n                return currentCredentials[key] !== credentials[key];\n              });\n              // If endpoint is already initialized, and nothing else is changing, just early return\n              if (this.endpointInitialized && !credentialsUpdated && !userId && !userInfo) {\n                return [2 /*return*/];\n              }\n              // Update credentials\n              this.config.credentials = currentCredentials;\n              _f.label = 2;\n            case 2:\n              _f.trys.push([2, 6,, 7]);\n              if (!(!pinpointClient || credentialsUpdated)) return [3 /*break*/, 4];\n              return [4 /*yield*/, this.initPinpointClient()];\n            case 3:\n              _f.sent();\n              _f.label = 4;\n            case 4:\n              _c = userInfo !== null && userInfo !== void 0 ? userInfo : {}, address = _c.address, attributes = _c.attributes, demographic = _c.demographic, location_1 = _c.location, metrics = _c.metrics, optOut = _c.optOut;\n              _d = this.clientInfo, appVersion = _d.appVersion, make = _d.make, model = _d.model, platform = _d.platform, version = _d.version;\n              input = {\n                ApplicationId: appId,\n                EndpointId: endpointId,\n                EndpointRequest: {\n                  RequestId: uuid(),\n                  EffectiveDate: new Date().toISOString(),\n                  ChannelType: ChannelType.IN_APP,\n                  Address: address !== null && address !== void 0 ? address : endpointInfo.address,\n                  Attributes: __assign(__assign({}, endpointInfo.attributes), attributes),\n                  Demographic: __assign({\n                    AppVersion: appVersion,\n                    Make: make,\n                    Model: model,\n                    ModelVersion: version,\n                    Platform: platform\n                  }, transferKeyToUpperCase(__assign(__assign({}, endpointInfo.demographic), demographic))),\n                  Location: transferKeyToUpperCase(__assign(__assign({}, endpointInfo.location), location_1)),\n                  Metrics: __assign(__assign({}, endpointInfo.metrics), metrics),\n                  OptOut: optOut !== null && optOut !== void 0 ? optOut : endpointInfo.optOut,\n                  User: {\n                    UserId: (_e = userId !== null && userId !== void 0 ? userId : endpointInfo.userId) !== null && _e !== void 0 ? _e : currentCredentials.identityId,\n                    UserAttributes: attributes !== null && attributes !== void 0 ? attributes : endpointInfo.userAttributes\n                  }\n                }\n              };\n              command = new UpdateEndpointCommand(input);\n              logger.debug('updating endpoint', input);\n              return [4 /*yield*/, this.config.pinpointClient.send(command)];\n            case 5:\n              _f.sent();\n              this.endpointInitialized = true;\n              return [3 /*break*/, 7];\n            case 6:\n              err_4 = _f.sent();\n              throw err_4;\n            case 7:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.getCredentials = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var credentials, err_5;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n              return [4 /*yield*/, Credentials.get()];\n            case 1:\n              credentials = _a.sent();\n              if (!credentials) {\n                logger.debug('no credentials found');\n                return [2 /*return*/, null];\n              }\n              return [2 /*return*/, Credentials.shear(credentials)];\n            case 2:\n              err_5 = _a.sent();\n              logger.error('Error getting credentials:', err_5);\n              return [2 /*return*/, null];\n            case 3:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.sessionStateChangeHandler = function (state) {\n      if (state === 'started') {\n        // reset all session counts\n        _this.sessionMessageCountMap = {};\n      }\n    };\n    this.isBelowCap = function (_a) {\n      var CampaignId = _a.CampaignId,\n        SessionCap = _a.SessionCap,\n        DailyCap = _a.DailyCap,\n        TotalCap = _a.TotalCap;\n      var _b = _this.getMessageCounts(CampaignId),\n        sessionCount = _b.sessionCount,\n        dailyCount = _b.dailyCount,\n        totalCount = _b.totalCount;\n      return (!SessionCap || sessionCount < SessionCap) && (!DailyCap || dailyCount < DailyCap) && (!TotalCap || totalCount < TotalCap);\n    };\n    // Use the current session count in memory or initialize as empty count\n    this.getSessionCount = function (messageId) {\n      return _this.sessionMessageCountMap[messageId] || 0;\n    };\n    this.getDailyCount = function () {\n      var storage = _this.config.storage;\n      var today = getStartOfDay();\n      var item = storage.getItem(MESSAGE_DAILY_COUNT_KEY);\n      // Parse stored count or initialize as empty count\n      var counter = item ? JSON.parse(item) : {\n        count: 0,\n        lastCountTimestamp: today\n      };\n      // If the stored counter timestamp is today, use it as the count, otherwise reset to 0\n      return counter.lastCountTimestamp === today ? counter.count : 0;\n    };\n    this.getTotalCountMap = function () {\n      var storage = _this.config.storage;\n      var item = storage.getItem(MESSAGE_TOTAL_COUNT_KEY);\n      // Parse stored count map or initialize as empty\n      return item ? JSON.parse(item) : {};\n    };\n    this.getTotalCount = function (messageId) {\n      var countMap = _this.getTotalCountMap();\n      // Return stored count or initialize as empty count\n      return countMap[messageId] || 0;\n    };\n    this.getMessageCounts = function (messageId) {\n      try {\n        return {\n          sessionCount: _this.getSessionCount(messageId),\n          dailyCount: _this.getDailyCount(),\n          totalCount: _this.getTotalCount(messageId)\n        };\n      } catch (err) {\n        logger.error('Failed to get message counts from storage', err);\n      }\n    };\n    this.setSessionCount = function (messageId, count) {\n      _this.sessionMessageCountMap[messageId] = count;\n    };\n    this.setDailyCount = function (count) {\n      var storage = _this.config.storage;\n      var dailyCount = {\n        count: count,\n        lastCountTimestamp: getStartOfDay()\n      };\n      try {\n        storage.setItem(MESSAGE_DAILY_COUNT_KEY, JSON.stringify(dailyCount));\n      } catch (err) {\n        logger.error('Failed to save daily message count to storage', err);\n      }\n    };\n    this.setTotalCountMap = function (countMap) {\n      var storage = _this.config.storage;\n      try {\n        storage.setItem(MESSAGE_TOTAL_COUNT_KEY, JSON.stringify(countMap));\n      } catch (err) {\n        logger.error('Failed to save total count to storage', err);\n      }\n    };\n    this.setTotalCount = function (messageId, count) {\n      var _a;\n      var updatedMap = __assign(__assign({}, _this.getTotalCountMap()), (_a = {}, _a[messageId] = count, _a));\n      _this.setTotalCountMap(updatedMap);\n    };\n    this.incrementCounts = function (messageId) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, sessionCount, dailyCount, totalCount;\n        return __generator(this, function (_b) {\n          _a = this.getMessageCounts(messageId), sessionCount = _a.sessionCount, dailyCount = _a.dailyCount, totalCount = _a.totalCount;\n          this.setSessionCount(messageId, sessionCount + 1);\n          this.setDailyCount(dailyCount + 1);\n          this.setTotalCount(messageId, totalCount + 1);\n          return [2 /*return*/];\n        });\n      });\n    };\n\n    this.normalizeMessages = function (messages) {\n      return messages.map(function (message) {\n        var CampaignId = message.CampaignId,\n          InAppMessage = message.InAppMessage;\n        return {\n          id: CampaignId,\n          content: extractContent(message),\n          layout: interpretLayout(InAppMessage.Layout),\n          metadata: extractMetadata(message)\n        };\n      });\n    };\n    this.recordMessageEvent = function (message, event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this.initialized) return [3 /*break*/, 2];\n              return [4 /*yield*/, this.init()];\n            case 1:\n              _a.sent();\n              _a.label = 2;\n            case 2:\n              recordAnalyticsEvent(event, message);\n              if (!(event === AWSPinpointMessageEvent.MESSAGE_DISPLAYED)) return [3 /*break*/, 4];\n              return [4 /*yield*/, this.incrementCounts(message.id)];\n            case 3:\n              _a.sent();\n              _a.label = 4;\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    };\n\n    this.sessionMessageCountMap = {};\n    this.config = {\n      storage: new StorageHelper().getStorage()\n    };\n    this.clientInfo = (_a = ClientDevice.clientInfo()) !== null && _a !== void 0 ? _a : {};\n  }\n  /**\n   * get the category of the plugin\n   */\n  AWSPinpointProvider.prototype.getCategory = function () {\n    return AWSPinpointProvider.category;\n  };\n  /**\n   * get the sub-category of the plugin\n   */\n  AWSPinpointProvider.prototype.getSubCategory = function () {\n    return AWSPinpointProvider.subCategory;\n  };\n  /**\n   * get provider name of the plugin\n   */\n  AWSPinpointProvider.prototype.getProviderName = function () {\n    return AWSPinpointProvider.providerName;\n  };\n  AWSPinpointProvider.category = 'Notifications';\n  AWSPinpointProvider.subCategory = 'InAppMessaging';\n  AWSPinpointProvider.providerName = 'AWSPinpoint';\n  return AWSPinpointProvider;\n}();\nexport default AWSPinpointProvider;","map":{"version":3,"names":["ClientDevice","Credentials","getAmplifyUserAgent","StorageHelper","transferKeyToUpperCase","Cache","ChannelType","GetInAppMessagesCommand","UpdateEndpointCommand","PinpointClient","v4","uuid","addMessageInteractionEventListener","SessionTracker","InAppMessageInteractionEvent","AWSPinpointMessageEvent","clearMemo","dispatchInAppMessagingEvent","extractContent","extractMetadata","getStartOfDay","interpretLayout","isBeforeEndDate","logger","matchesAttributes","matchesEventType","matchesMetrics","recordAnalyticsEvent","MESSAGE_DAILY_COUNT_KEY","MESSAGE_TOTAL_COUNT_KEY","AWSPinpointProvider","_this","config","configured","endpointInitialized","initialized","configure","__assign","debug","sessionTracker","sessionStateChangeHandler","start","message","recordMessageEvent","MESSAGE_DISPLAYED","MESSAGE_DISMISSED","MESSAGE_ACTION_TAKEN","getInAppMessages","__awaiter","init","_b","sent","updateEndpoint","_a","appId","endpointId","pinpointClient","input","ApplicationId","EndpointId","command","send","response","messages","InAppMessagesResponse","InAppMessageCampaigns","error","err_1","processInAppMessages","event","normalizeMessages","reduce","acc","messageQualifies","isBelowCap","highestPrioritySeen","Priority","push","identifyUser","userId","userInfo","err_2","storage","providerName","getProviderName","sync","_c","getEndpointId","err_3","initPinpointClient","credentials","region","Error","destroy","customUserAgent","cacheKey","getSubCategory","getItem","cachedEndpointId","ttl","expiration","Date","getTime","setItem","expires","priority","endpointInfo","getCredentials","currentCredentials","_f","credentialsUpdated","Object","keys","some","key","address","attributes","demographic","location_1","location","metrics","optOut","_d","clientInfo","appVersion","make","model","platform","version","EndpointRequest","RequestId","EffectiveDate","toISOString","IN_APP","Address","Attributes","Demographic","AppVersion","Make","Model","ModelVersion","Platform","Location","Metrics","OptOut","User","UserId","_e","identityId","UserAttributes","userAttributes","err_4","get","shear","err_5","state","sessionMessageCountMap","CampaignId","SessionCap","DailyCap","TotalCap","getMessageCounts","sessionCount","dailyCount","totalCount","getSessionCount","messageId","getDailyCount","today","item","counter","JSON","parse","count","lastCountTimestamp","getTotalCountMap","getTotalCount","countMap","err","setSessionCount","setDailyCount","stringify","setTotalCountMap","setTotalCount","updatedMap","incrementCounts","map","InAppMessage","id","content","layout","Layout","metadata","getStorage","prototype","getCategory","category","subCategory"],"sources":["/Users/ericli/node_modules/@aws-amplify/notifications/src/InAppMessaging/Providers/AWSPinpointProvider/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tClientDevice,\n\tCredentials,\n\tgetAmplifyUserAgent,\n\tStorageHelper,\n\ttransferKeyToUpperCase,\n} from '@aws-amplify/core';\nimport { Cache } from '@aws-amplify/cache';\nimport {\n\tChannelType,\n\tGetInAppMessagesCommand,\n\tGetInAppMessagesCommandInput,\n\tInAppMessageCampaign as PinpointInAppMessage,\n\tUpdateEndpointCommand,\n\tUpdateEndpointCommandInput,\n\tPinpointClient,\n} from '@aws-sdk/client-pinpoint';\nimport { v4 as uuid } from 'uuid';\n\nimport { addMessageInteractionEventListener } from '../../eventListeners';\nimport { NotificationsCategory } from '../../../types';\nimport SessionTracker, {\n\tSessionState,\n\tSessionStateChangeHandler,\n} from '../../SessionTracker';\nimport {\n\tInAppMessage,\n\tInAppMessageInteractionEvent,\n\tInAppMessageLayout,\n\tInAppMessagingEvent,\n\tInAppMessagingProvider,\n\tNotificationsSubcategory,\n\tUserInfo,\n} from '../../types';\nimport {\n\tAWSPinpointMessageEvent,\n\tAWSPinpointUserInfo,\n\tDailyInAppMessageCounter,\n\tInAppMessageCountMap,\n\tInAppMessageCounts,\n} from './types';\nimport {\n\tclearMemo,\n\tdispatchInAppMessagingEvent,\n\textractContent,\n\textractMetadata,\n\tgetStartOfDay,\n\tinterpretLayout,\n\tisBeforeEndDate,\n\tlogger,\n\tmatchesAttributes,\n\tmatchesEventType,\n\tmatchesMetrics,\n\trecordAnalyticsEvent,\n} from './utils';\n\nconst MESSAGE_DAILY_COUNT_KEY = 'pinpointProvider_inAppMessages_dailyCount';\nconst MESSAGE_TOTAL_COUNT_KEY = 'pinpointProvider_inAppMessages_totalCount';\n\nexport default class AWSPinpointProvider implements InAppMessagingProvider {\n\tstatic category: NotificationsCategory = 'Notifications';\n\tstatic subCategory: NotificationsSubcategory = 'InAppMessaging';\n\tstatic providerName = 'AWSPinpoint';\n\n\tprivate clientInfo;\n\tprivate config: Record<string, any> = {};\n\tprivate configured = false;\n\tprivate endpointInitialized = false;\n\tprivate initialized = false;\n\tprivate sessionMessageCountMap: InAppMessageCountMap;\n\tprivate sessionTracker: SessionTracker;\n\n\tconstructor() {\n\t\tthis.sessionMessageCountMap = {};\n\t\tthis.config = {\n\t\t\tstorage: new StorageHelper().getStorage(),\n\t\t};\n\t\tthis.clientInfo = ClientDevice.clientInfo() ?? {};\n\t}\n\n\t/**\n\t * get the category of the plugin\n\t */\n\tgetCategory() {\n\t\treturn AWSPinpointProvider.category;\n\t}\n\n\t/**\n\t * get the sub-category of the plugin\n\t */\n\tgetSubCategory() {\n\t\treturn AWSPinpointProvider.subCategory;\n\t}\n\n\t/**\n\t * get provider name of the plugin\n\t */\n\tgetProviderName(): string {\n\t\treturn AWSPinpointProvider.providerName;\n\t}\n\n\tconfigure = (config = {}): object => {\n\t\tthis.config = { ...this.config, ...config };\n\n\t\tlogger.debug('configure AWSPinpointProvider', this.config);\n\n\t\t// some configuration steps should not be re-run even if provider is re-configured for some reason\n\t\tif (!this.configured) {\n\t\t\tthis.sessionTracker = new SessionTracker(this.sessionStateChangeHandler);\n\t\t\tthis.sessionTracker.start();\n\t\t\t// wire up default Pinpoint message event handling\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_DISPLAYED\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_DISPLAYED);\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_DISMISSED\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_DISMISSED);\n\t\t\taddMessageInteractionEventListener((message: InAppMessage) => {\n\t\t\t\tthis.recordMessageEvent(\n\t\t\t\t\tmessage,\n\t\t\t\t\tAWSPinpointMessageEvent.MESSAGE_ACTION_TAKEN\n\t\t\t\t);\n\t\t\t}, InAppMessageInteractionEvent.MESSAGE_ACTION_TAKEN);\n\t\t}\n\n\t\tthis.configured = true;\n\t\tdispatchInAppMessagingEvent('pinpointProvider_configured', null);\n\t\treturn this.config;\n\t};\n\n\tgetInAppMessages = async () => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\t// There is no way to granuarly reconcile the filter memoization as the keys are composited from a message id and\n\t\t// event properties thus opting to just clear them out when getting messages rather than leave potentially\n\t\t// obsolete entries that will no longer serve any purpose.\n\t\tclearMemo();\n\t\ttry {\n\t\t\tawait this.updateEndpoint();\n\t\t\tconst { appId, endpointId, pinpointClient } = this.config;\n\t\t\tconst input: GetInAppMessagesCommandInput = {\n\t\t\t\tApplicationId: appId,\n\t\t\t\tEndpointId: endpointId,\n\t\t\t};\n\t\t\tconst command: GetInAppMessagesCommand = new GetInAppMessagesCommand(\n\t\t\t\tinput\n\t\t\t);\n\t\t\tlogger.debug('getting in-app messages', input);\n\t\t\tconst response = await pinpointClient.send(command);\n\t\t\tconst { InAppMessageCampaigns: messages } =\n\t\t\t\tresponse.InAppMessagesResponse;\n\t\t\tdispatchInAppMessagingEvent('getInAppMessages', messages);\n\t\t\treturn messages;\n\t\t} catch (err) {\n\t\t\tlogger.error('Error getting in-app messages', err);\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprocessInAppMessages = async (\n\t\tmessages: any[],\n\t\tevent: InAppMessagingEvent\n\t): Promise<InAppMessage[]> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\tlet highestPrioritySeen;\n\t\treturn this.normalizeMessages(\n\t\t\t(messages as PinpointInAppMessage[]).reduce((acc, message) => {\n\t\t\t\tconst messageQualifies =\n\t\t\t\t\tmatchesEventType(message, event) &&\n\t\t\t\t\tmatchesAttributes(message, event) &&\n\t\t\t\t\tmatchesMetrics(message, event) &&\n\t\t\t\t\tisBeforeEndDate(message) &&\n\t\t\t\t\tthis.isBelowCap(message);\n\t\t\t\t// filter all qualifying messages returning only those that are of (relative) highest priority\n\t\t\t\tif (messageQualifies) {\n\t\t\t\t\t// have not yet encountered message with priority\n\t\t\t\t\tif (!highestPrioritySeen) {\n\t\t\t\t\t\t// this message has priority, so reset the accumulator with this message only\n\t\t\t\t\t\tif (message.Priority) {\n\t\t\t\t\t\t\thighestPrioritySeen = message.Priority;\n\t\t\t\t\t\t\treturn [message];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// this message also has no priority, so just add this message to accumulator\n\t\t\t\t\t\t\tacc.push(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// have previously encountered message with priority, so only messages with priority matter now\n\t\t\t\t\t} else if (message.Priority) {\n\t\t\t\t\t\t// this message has higher priority (lower number), so reset the accumulator with this message only\n\t\t\t\t\t\tif (message.Priority < highestPrioritySeen) {\n\t\t\t\t\t\t\thighestPrioritySeen = message.Priority;\n\t\t\t\t\t\t\treturn [message];\n\t\t\t\t\t\t\t// this message has the same priority, so just add this message to accumulator\n\t\t\t\t\t\t} else if (message.Priority === highestPrioritySeen) {\n\t\t\t\t\t\t\tacc.push(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn acc;\n\t\t\t}, [])\n\t\t);\n\t};\n\n\tidentifyUser = async (userId: string, userInfo: UserInfo): Promise<void> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\ttry {\n\t\t\tawait this.updateEndpoint(userId, userInfo);\n\t\t} catch (err) {\n\t\t\tlogger.error('Error identifying user', err);\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprivate init = async () => {\n\t\tconst { endpointId, storage } = this.config;\n\t\tconst providerName = this.getProviderName();\n\t\ttry {\n\t\t\t// Only run sync() if it's available (i.e. React Native)\n\t\t\tif (typeof storage.sync === 'function') {\n\t\t\t\tawait storage.sync();\n\t\t\t}\n\t\t\t// If an endpoint was not provided via configuration, try to get it from cache\n\t\t\tif (!endpointId) {\n\t\t\t\tthis.config.endpointId = await this.getEndpointId();\n\t\t\t}\n\t\t\tthis.initialized = true;\n\t\t} catch (err) {\n\t\t\tlogger.error(`Failed to initialize ${providerName}`, err);\n\t\t}\n\t};\n\n\tprivate initPinpointClient = async () => {\n\t\tconst { appId, credentials, pinpointClient, region } = this.config;\n\n\t\tif (!appId || !credentials || !region) {\n\t\t\tthrow new Error(\n\t\t\t\t'One or more of credentials, appId or region is not configured'\n\t\t\t);\n\t\t}\n\n\t\tif (pinpointClient) {\n\t\t\tpinpointClient.destroy();\n\t\t}\n\n\t\tthis.config.pinpointClient = new PinpointClient({\n\t\t\tregion,\n\t\t\tcredentials,\n\t\t\tcustomUserAgent: getAmplifyUserAgent(),\n\t\t});\n\t};\n\n\tprivate getEndpointId = async () => {\n\t\tconst { appId } = this.config;\n\t\t// Each Pinpoint channel requires its own Endpoint ID\n\t\tconst cacheKey = `${this.getSubCategory()}:${this.getProviderName()}:${appId}`;\n\t\t// First attempt to retrieve the ID from cache\n\t\tconst cachedEndpointId = await Cache.getItem(cacheKey);\n\t\t// Found in cache, just return it\n\t\tif (cachedEndpointId) {\n\t\t\treturn cachedEndpointId;\n\t\t}\n\t\t// Otherwise, generate a new ID and store it in long-lived cache before returning it\n\t\tconst endpointId = uuid();\n\t\t// Set a longer TTL to avoid endpoint id being deleted after the default TTL (3 days)\n\t\t// Also set its priority to the highest to reduce its chance of being deleted when cache is full\n\t\tconst ttl = 1000 * 60 * 60 * 24 * 365 * 100; // 100 years\n\t\tconst expiration = new Date().getTime() + ttl;\n\t\tCache.setItem(cacheKey, endpointId, {\n\t\t\texpires: expiration,\n\t\t\tpriority: 1,\n\t\t});\n\t\treturn endpointId;\n\t};\n\n\tprivate updateEndpoint = async (\n\t\tuserId: string = null,\n\t\tuserInfo: AWSPinpointUserInfo = null\n\t) => {\n\t\tconst {\n\t\t\tappId,\n\t\t\tcredentials,\n\t\t\tendpointId,\n\t\t\tendpointInfo = {},\n\t\t\tpinpointClient,\n\t\t} = this.config;\n\t\tconst currentCredentials = await this.getCredentials();\n\t\t// Shallow compare to determine if credentials stored here are outdated\n\t\tconst credentialsUpdated =\n\t\t\t!credentials ||\n\t\t\tObject.keys(currentCredentials).some(\n\t\t\t\tkey => currentCredentials[key] !== credentials[key]\n\t\t\t);\n\t\t// If endpoint is already initialized, and nothing else is changing, just early return\n\t\tif (\n\t\t\tthis.endpointInitialized &&\n\t\t\t!credentialsUpdated &&\n\t\t\t!userId &&\n\t\t\t!userInfo\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\t// Update credentials\n\t\tthis.config.credentials = currentCredentials;\n\t\ttry {\n\t\t\t// Initialize a new pinpoint client if one isn't already configured or if credentials changed\n\t\t\tif (!pinpointClient || credentialsUpdated) {\n\t\t\t\tawait this.initPinpointClient();\n\t\t\t}\n\t\t\tconst { address, attributes, demographic, location, metrics, optOut } =\n\t\t\t\tuserInfo ?? {};\n\t\t\tconst { appVersion, make, model, platform, version } = this.clientInfo;\n\t\t\t// Create the UpdateEndpoint input, prioritizing passed in user info and falling back to\n\t\t\t// defaults (if any) obtained from the config\n\t\t\tconst input: UpdateEndpointCommandInput = {\n\t\t\t\tApplicationId: appId,\n\t\t\t\tEndpointId: endpointId,\n\t\t\t\tEndpointRequest: {\n\t\t\t\t\tRequestId: uuid(),\n\t\t\t\t\tEffectiveDate: new Date().toISOString(),\n\t\t\t\t\tChannelType: ChannelType.IN_APP,\n\t\t\t\t\tAddress: address ?? endpointInfo.address,\n\t\t\t\t\tAttributes: {\n\t\t\t\t\t\t...endpointInfo.attributes,\n\t\t\t\t\t\t...attributes,\n\t\t\t\t\t},\n\t\t\t\t\tDemographic: {\n\t\t\t\t\t\tAppVersion: appVersion,\n\t\t\t\t\t\tMake: make,\n\t\t\t\t\t\tModel: model,\n\t\t\t\t\t\tModelVersion: version,\n\t\t\t\t\t\tPlatform: platform,\n\t\t\t\t\t\t...transferKeyToUpperCase({\n\t\t\t\t\t\t\t...endpointInfo.demographic,\n\t\t\t\t\t\t\t...demographic,\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t\tLocation: transferKeyToUpperCase({\n\t\t\t\t\t\t...endpointInfo.location,\n\t\t\t\t\t\t...location,\n\t\t\t\t\t}),\n\t\t\t\t\tMetrics: {\n\t\t\t\t\t\t...endpointInfo.metrics,\n\t\t\t\t\t\t...metrics,\n\t\t\t\t\t},\n\t\t\t\t\tOptOut: optOut ?? endpointInfo.optOut,\n\t\t\t\t\tUser: {\n\t\t\t\t\t\tUserId:\n\t\t\t\t\t\t\tuserId ?? endpointInfo.userId ?? currentCredentials.identityId,\n\t\t\t\t\t\tUserAttributes: attributes ?? endpointInfo.userAttributes,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\t\t\tconst command: UpdateEndpointCommand = new UpdateEndpointCommand(input);\n\t\t\tlogger.debug('updating endpoint', input);\n\t\t\tawait this.config.pinpointClient.send(command);\n\t\t\tthis.endpointInitialized = true;\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tprivate getCredentials = async () => {\n\t\ttry {\n\t\t\tconst credentials = await Credentials.get();\n\t\t\tif (!credentials) {\n\t\t\t\tlogger.debug('no credentials found');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Credentials.shear(credentials);\n\t\t} catch (err) {\n\t\t\tlogger.error('Error getting credentials:', err);\n\t\t\treturn null;\n\t\t}\n\t};\n\n\tprivate sessionStateChangeHandler: SessionStateChangeHandler = (\n\t\tstate: SessionState\n\t) => {\n\t\tif (state === 'started') {\n\t\t\t// reset all session counts\n\t\t\tthis.sessionMessageCountMap = {};\n\t\t}\n\t};\n\n\tprivate isBelowCap = ({\n\t\tCampaignId,\n\t\tSessionCap,\n\t\tDailyCap,\n\t\tTotalCap,\n\t}: PinpointInAppMessage): boolean => {\n\t\tconst { sessionCount, dailyCount, totalCount } =\n\t\t\tthis.getMessageCounts(CampaignId);\n\t\treturn (\n\t\t\t(!SessionCap || sessionCount < SessionCap) &&\n\t\t\t(!DailyCap || dailyCount < DailyCap) &&\n\t\t\t(!TotalCap || totalCount < TotalCap)\n\t\t);\n\t};\n\n\t// Use the current session count in memory or initialize as empty count\n\tprivate getSessionCount = (messageId: string): number =>\n\t\tthis.sessionMessageCountMap[messageId] || 0;\n\n\tprivate getDailyCount = (): number => {\n\t\tconst { storage } = this.config;\n\t\tconst today = getStartOfDay();\n\t\tconst item = storage.getItem(MESSAGE_DAILY_COUNT_KEY);\n\t\t// Parse stored count or initialize as empty count\n\t\tconst counter: DailyInAppMessageCounter = item\n\t\t\t? JSON.parse(item)\n\t\t\t: { count: 0, lastCountTimestamp: today };\n\t\t// If the stored counter timestamp is today, use it as the count, otherwise reset to 0\n\t\treturn counter.lastCountTimestamp === today ? counter.count : 0;\n\t};\n\n\tprivate getTotalCountMap = (): InAppMessageCountMap => {\n\t\tconst { storage } = this.config;\n\t\tconst item = storage.getItem(MESSAGE_TOTAL_COUNT_KEY);\n\t\t// Parse stored count map or initialize as empty\n\t\treturn item ? JSON.parse(item) : {};\n\t};\n\n\tprivate getTotalCount = (messageId: string): number => {\n\t\tconst countMap = this.getTotalCountMap();\n\t\t// Return stored count or initialize as empty count\n\t\treturn countMap[messageId] || 0;\n\t};\n\n\tprivate getMessageCounts = (messageId: string): InAppMessageCounts => {\n\t\ttry {\n\t\t\treturn {\n\t\t\t\tsessionCount: this.getSessionCount(messageId),\n\t\t\t\tdailyCount: this.getDailyCount(),\n\t\t\t\ttotalCount: this.getTotalCount(messageId),\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to get message counts from storage', err);\n\t\t}\n\t};\n\n\tprivate setSessionCount = (messageId: string, count: number): void => {\n\t\tthis.sessionMessageCountMap[messageId] = count;\n\t};\n\n\tprivate setDailyCount = (count: number): void => {\n\t\tconst { storage } = this.config;\n\t\tconst dailyCount: DailyInAppMessageCounter = {\n\t\t\tcount,\n\t\t\tlastCountTimestamp: getStartOfDay(),\n\t\t};\n\t\ttry {\n\t\t\tstorage.setItem(MESSAGE_DAILY_COUNT_KEY, JSON.stringify(dailyCount));\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to save daily message count to storage', err);\n\t\t}\n\t};\n\n\tprivate setTotalCountMap = (countMap: InAppMessageCountMap): void => {\n\t\tconst { storage } = this.config;\n\t\ttry {\n\t\t\tstorage.setItem(MESSAGE_TOTAL_COUNT_KEY, JSON.stringify(countMap));\n\t\t} catch (err) {\n\t\t\tlogger.error('Failed to save total count to storage', err);\n\t\t}\n\t};\n\n\tprivate setTotalCount = (messageId: string, count: number): void => {\n\t\tconst updatedMap = {\n\t\t\t...this.getTotalCountMap(),\n\t\t\t[messageId]: count,\n\t\t};\n\t\tthis.setTotalCountMap(updatedMap);\n\t};\n\n\tprivate incrementCounts = async (messageId: string): Promise<void> => {\n\t\tconst { sessionCount, dailyCount, totalCount } =\n\t\t\tthis.getMessageCounts(messageId);\n\t\tthis.setSessionCount(messageId, sessionCount + 1);\n\t\tthis.setDailyCount(dailyCount + 1);\n\t\tthis.setTotalCount(messageId, totalCount + 1);\n\t};\n\n\tprivate normalizeMessages = (\n\t\tmessages: PinpointInAppMessage[]\n\t): InAppMessage[] => {\n\t\treturn messages.map(message => {\n\t\t\tconst { CampaignId, InAppMessage } = message;\n\t\t\treturn {\n\t\t\t\tid: CampaignId,\n\t\t\t\tcontent: extractContent(message),\n\t\t\t\tlayout: interpretLayout(InAppMessage.Layout),\n\t\t\t\tmetadata: extractMetadata(message),\n\t\t\t};\n\t\t});\n\t};\n\n\tprivate recordMessageEvent = async (\n\t\tmessage: InAppMessage,\n\t\tevent: AWSPinpointMessageEvent\n\t): Promise<void> => {\n\t\tif (!this.initialized) {\n\t\t\tawait this.init();\n\t\t}\n\t\trecordAnalyticsEvent(event, message);\n\t\tif (event === AWSPinpointMessageEvent.MESSAGE_DISPLAYED) {\n\t\t\tawait this.incrementCounts(message.id);\n\t\t}\n\t};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}