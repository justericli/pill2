{"ast":null,"code":"import _objectSpread from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"assign\"];\nimport { debugId, toDebugString } from \"../debug\";\nimport { EndpointError } from \"../types\";\nimport { callFunction } from \"./callFunction\";\nexport var evaluateCondition = function evaluateCondition(_ref, options) {\n  var _options$logger, _options$logger$debug;\n  var assign = _ref.assign,\n    fnArgs = _objectWithoutProperties(_ref, _excluded);\n  if (assign && assign in options.referenceRecord) {\n    throw new EndpointError(\"'\".concat(assign, \"' is already defined in Reference Record.\"));\n  }\n  var value = callFunction(fnArgs, options);\n  (_options$logger = options.logger) === null || _options$logger === void 0 ? void 0 : (_options$logger$debug = _options$logger.debug) === null || _options$logger$debug === void 0 ? void 0 : _options$logger$debug.call(_options$logger, debugId, \"evaluateCondition: \".concat(toDebugString(fnArgs), \" = \").concat(toDebugString(value)));\n  return _objectSpread({\n    result: value === \"\" ? true : !!value\n  }, assign != null && {\n    toAssign: {\n      name: assign,\n      value: value\n    }\n  });\n};","map":{"version":3,"names":["debugId","toDebugString","EndpointError","callFunction","evaluateCondition","_ref","options","_options$logger","_options$logger$debug","assign","fnArgs","_objectWithoutProperties","_excluded","referenceRecord","concat","value","logger","debug","call","_objectSpread","result","toAssign","name"],"sources":["/Users/ericli/Desktop/pill2/node_modules/@aws-sdk/util-endpoints/dist-es/utils/evaluateCondition.js"],"sourcesContent":["import { debugId, toDebugString } from \"../debug\";\nimport { EndpointError } from \"../types\";\nimport { callFunction } from \"./callFunction\";\nexport const evaluateCondition = ({ assign, ...fnArgs }, options) => {\n    if (assign && assign in options.referenceRecord) {\n        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);\n    }\n    const value = callFunction(fnArgs, options);\n    options.logger?.debug?.(debugId, `evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);\n    return {\n        result: value === \"\" ? true : !!value,\n        ...(assign != null && { toAssign: { name: assign, value } }),\n    };\n};\n"],"mappings":";;;AAAA,SAASA,OAAO,EAAEC,aAAa,QAAQ,UAAU;AACjD,SAASC,aAAa,QAAQ,UAAU;AACxC,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,OAAO,IAAMC,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAAC,IAAA,EAA2BC,OAAO,EAAK;EAAA,IAAAC,eAAA,EAAAC,qBAAA;EAAA,IAAjCC,MAAM,GAAAJ,IAAA,CAANI,MAAM;IAAKC,MAAM,GAAAC,wBAAA,CAAAN,IAAA,EAAAO,SAAA;EACjD,IAAIH,MAAM,IAAIA,MAAM,IAAIH,OAAO,CAACO,eAAe,EAAE;IAC7C,MAAM,IAAIX,aAAa,KAAAY,MAAA,CAAKL,MAAM,+CAA4C;EAClF;EACA,IAAMM,KAAK,GAAGZ,YAAY,CAACO,MAAM,EAAEJ,OAAO,CAAC;EAC3C,CAAAC,eAAA,GAAAD,OAAO,CAACU,MAAM,cAAAT,eAAA,wBAAAC,qBAAA,GAAdD,eAAA,CAAgBU,KAAK,cAAAT,qBAAA,uBAArBA,qBAAA,CAAAU,IAAA,CAAAX,eAAA,EAAwBP,OAAO,wBAAAc,MAAA,CAAwBb,aAAa,CAACS,MAAM,CAAC,SAAAI,MAAA,CAAMb,aAAa,CAACc,KAAK,CAAC,EAAG;EACzG,OAAAI,aAAA;IACIC,MAAM,EAAEL,KAAK,KAAK,EAAE,GAAG,IAAI,GAAG,CAAC,CAACA;EAAK,GACjCN,MAAM,IAAI,IAAI,IAAI;IAAEY,QAAQ,EAAE;MAAEC,IAAI,EAAEb,MAAM;MAAEM,KAAK,EAALA;IAAM;EAAE,CAAC;AAEnE,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}