{"ast":null,"code":"import { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { toUint8Array } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4 {\n  constructor(_ref) {\n    let {\n      applyChecksum,\n      credentials,\n      region,\n      service,\n      sha256,\n      uriEscapePath = true\n    } = _ref;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeProvider(region);\n    this.credentialProvider = normalizeProvider(credentials);\n  }\n  async presign(originalRequest) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      signingRegion,\n      signingService\n    } = options;\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      longDate,\n      shortDate\n    } = formatDate(signingDate);\n    if (expiresIn > MAX_PRESIGNED_TTL) {\n      return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n    }\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const request = moveHeadersToQuery(prepareRequest(originalRequest), {\n      unhoistableHeaders\n    });\n    if (credentials.sessionToken) {\n      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n    }\n    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n    request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n    return request;\n  }\n  async sign(toSign, options) {\n    if (typeof toSign === \"string\") {\n      return this.signString(toSign, options);\n    } else if (toSign.headers && toSign.payload) {\n      return this.signEvent(toSign, options);\n    } else {\n      return this.signRequest(toSign, options);\n    }\n  }\n  async signEvent(_ref2, _ref3) {\n    let {\n      headers,\n      payload\n    } = _ref2;\n    let {\n      signingDate = new Date(),\n      priorSignature,\n      signingRegion,\n      signingService\n    } = _ref3;\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      shortDate,\n      longDate\n    } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const hashedPayload = await getPayloadHash({\n      headers: {},\n      body: payload\n    }, this.sha256);\n    const hash = new this.sha256();\n    hash.update(headers);\n    const hashedHeaders = toHex(await hash.digest());\n    const stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n    return this.signString(stringToSign, {\n      signingDate,\n      signingRegion: region,\n      signingService\n    });\n  }\n  async signString(stringToSign) {\n    let {\n      signingDate = new Date(),\n      signingRegion,\n      signingService\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      shortDate\n    } = formatDate(signingDate);\n    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n    hash.update(toUint8Array(stringToSign));\n    return toHex(await hash.digest());\n  }\n  async signRequest(requestToSign) {\n    let {\n      signingDate = new Date(),\n      signableHeaders,\n      unsignableHeaders,\n      signingRegion,\n      signingService\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const request = prepareRequest(requestToSign);\n    const {\n      longDate,\n      shortDate\n    } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    request.headers[AMZ_DATE_HEADER] = longDate;\n    if (credentials.sessionToken) {\n      request.headers[TOKEN_HEADER] = credentials.sessionToken;\n    }\n    const payloadHash = await getPayloadHash(request, this.sha256);\n    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n      request.headers[SHA256_HEADER] = payloadHash;\n    }\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;\n    return request;\n  }\n  createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map(name => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n  async createStringToSign(longDate, credentialScope, canonicalRequest) {\n    const hash = new this.sha256();\n    hash.update(toUint8Array(canonicalRequest));\n    const hashedRequest = await hash.digest();\n    return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n  }\n  getCanonicalPath(_ref4) {\n    let {\n      path\n    } = _ref4;\n    if (this.uriEscapePath) {\n      const normalizedPathSegments = [];\n      for (const pathSegment of path.split(\"/\")) {\n        if (pathSegment?.length === 0) continue;\n        if (pathSegment === \".\") continue;\n        if (pathSegment === \"..\") {\n          normalizedPathSegments.pop();\n        } else {\n          normalizedPathSegments.push(pathSegment);\n        }\n      }\n      const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n      const doubleEncoded = encodeURIComponent(normalizedPath);\n      return doubleEncoded.replace(/%2F/g, \"/\");\n    }\n    return path;\n  }\n  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n    const hash = new this.sha256(await keyPromise);\n    hash.update(toUint8Array(stringToSign));\n    return toHex(await hash.digest());\n  }\n  getSigningKey(credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n  validateResolvedCredentials(credentials) {\n    if (typeof credentials !== \"object\" || typeof credentials.accessKeyId !== \"string\" || typeof credentials.secretAccessKey !== \"string\") {\n      throw new Error(\"Resolved credential object is not valid\");\n    }\n  }\n}\nconst formatDate = now => {\n  const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.slice(0, 8)\n  };\n};\nconst getCanonicalHeaderList = headers => Object.keys(headers).sort().join(\";\");","map":{"version":3,"names":["toHex","normalizeProvider","toUint8Array","ALGORITHM_IDENTIFIER","ALGORITHM_QUERY_PARAM","AMZ_DATE_HEADER","AMZ_DATE_QUERY_PARAM","AUTH_HEADER","CREDENTIAL_QUERY_PARAM","EVENT_ALGORITHM_IDENTIFIER","EXPIRES_QUERY_PARAM","MAX_PRESIGNED_TTL","SHA256_HEADER","SIGNATURE_QUERY_PARAM","SIGNED_HEADERS_QUERY_PARAM","TOKEN_HEADER","TOKEN_QUERY_PARAM","createScope","getSigningKey","getCanonicalHeaders","getCanonicalQuery","getPayloadHash","hasHeader","moveHeadersToQuery","prepareRequest","iso8601","SignatureV4","constructor","_ref","applyChecksum","credentials","region","service","sha256","uriEscapePath","regionProvider","credentialProvider","presign","originalRequest","options","arguments","length","undefined","signingDate","Date","expiresIn","unsignableHeaders","unhoistableHeaders","signableHeaders","signingRegion","signingService","validateResolvedCredentials","longDate","shortDate","formatDate","Promise","reject","scope","request","sessionToken","query","accessKeyId","toString","canonicalHeaders","getCanonicalHeaderList","getSignature","createCanonicalRequest","sign","toSign","signString","headers","payload","signEvent","signRequest","_ref2","_ref3","priorSignature","hashedPayload","body","hash","update","hashedHeaders","digest","stringToSign","join","requestToSign","payloadHash","signature","sortedHeaders","Object","keys","sort","method","getCanonicalPath","map","name","createStringToSign","credentialScope","canonicalRequest","hashedRequest","_ref4","path","normalizedPathSegments","pathSegment","split","pop","push","normalizedPath","startsWith","endsWith","doubleEncoded","encodeURIComponent","replace","keyPromise","secretAccessKey","Error","now","slice"],"sources":["/Users/ericli/Desktop/pill2/node_modules/@aws-sdk/client-s3/node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js"],"sourcesContent":["import { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { toUint8Array } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4 {\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        this.service = service;\n        this.sha256 = sha256;\n        this.uriEscapePath = uriEscapePath;\n        this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n        this.regionProvider = normalizeProvider(region);\n        this.credentialProvider = normalizeProvider(credentials);\n    }\n    async presign(originalRequest, options = {}) {\n        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { longDate, shortDate } = formatDate(signingDate);\n        if (expiresIn > MAX_PRESIGNED_TTL) {\n            return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n        }\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });\n        if (credentials.sessionToken) {\n            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n        }\n        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n        request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n        return request;\n    }\n    async sign(toSign, options) {\n        if (typeof toSign === \"string\") {\n            return this.signString(toSign, options);\n        }\n        else if (toSign.headers && toSign.payload) {\n            return this.signEvent(toSign, options);\n        }\n        else {\n            return this.signRequest(toSign, options);\n        }\n    }\n    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate, longDate } = formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);\n        const hash = new this.sha256();\n        hash.update(headers);\n        const hashedHeaders = toHex(await hash.digest());\n        const stringToSign = [\n            EVENT_ALGORITHM_IDENTIFIER,\n            longDate,\n            scope,\n            priorSignature,\n            hashedHeaders,\n            hashedPayload,\n        ].join(\"\\n\");\n        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n    }\n    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate } = formatDate(signingDate);\n        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const request = prepareRequest(requestToSign);\n        const { longDate, shortDate } = formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        request.headers[AMZ_DATE_HEADER] = longDate;\n        if (credentials.sessionToken) {\n            request.headers[TOKEN_HEADER] = credentials.sessionToken;\n        }\n        const payloadHash = await getPayloadHash(request, this.sha256);\n        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n            request.headers[SHA256_HEADER] = payloadHash;\n        }\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n        request.headers[AUTH_HEADER] =\n            `${ALGORITHM_IDENTIFIER} ` +\n                `Credential=${credentials.accessKeyId}/${scope}, ` +\n                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +\n                `Signature=${signature}`;\n        return request;\n    }\n    createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort();\n        return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n    }\n    async createStringToSign(longDate, credentialScope, canonicalRequest) {\n        const hash = new this.sha256();\n        hash.update(toUint8Array(canonicalRequest));\n        const hashedRequest = await hash.digest();\n        return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n    }\n    getCanonicalPath({ path }) {\n        if (this.uriEscapePath) {\n            const normalizedPathSegments = [];\n            for (const pathSegment of path.split(\"/\")) {\n                if (pathSegment?.length === 0)\n                    continue;\n                if (pathSegment === \".\")\n                    continue;\n                if (pathSegment === \"..\") {\n                    normalizedPathSegments.pop();\n                }\n                else {\n                    normalizedPathSegments.push(pathSegment);\n                }\n            }\n            const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n            const doubleEncoded = encodeURIComponent(normalizedPath);\n            return doubleEncoded.replace(/%2F/g, \"/\");\n        }\n        return path;\n    }\n    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n        const hash = new this.sha256(await keyPromise);\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    getSigningKey(credentials, region, shortDate, service) {\n        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n    }\n    validateResolvedCredentials(credentials) {\n        if (typeof credentials !== \"object\" ||\n            typeof credentials.accessKeyId !== \"string\" ||\n            typeof credentials.secretAccessKey !== \"string\") {\n            throw new Error(\"Resolved credential object is not valid\");\n        }\n    }\n}\nconst formatDate = (now) => {\n    const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n    return {\n        longDate,\n        shortDate: longDate.slice(0, 8),\n    };\n};\nconst getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(\";\");\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}