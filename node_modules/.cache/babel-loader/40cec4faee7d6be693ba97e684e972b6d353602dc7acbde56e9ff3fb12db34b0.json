{"ast":null,"code":"import _defineProperty from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _regeneratorRuntime from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _awaitAsyncGenerator from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/ericli/Desktop/pill2/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nexport function getChunkedStream(source) {\n  var currentMessageTotalLength = 0;\n  var currentMessagePendingLength = 0;\n  var currentMessage = null;\n  var messageLengthBuffer = null;\n  var allocateMessage = function allocateMessage(size) {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    var currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false);\n  };\n  var iterator = /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var sourceIterator, _yield$_awaitAsyncGen, value, done, chunkLength, currentOffset, bytesRemaining, numBytesForTotal, numBytesToWrite;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            sourceIterator = source[Symbol.asyncIterator]();\n          case 1:\n            if (!true) {\n              _context.next = 47;\n              break;\n            }\n            _context.next = 4;\n            return _awaitAsyncGenerator(sourceIterator.next());\n          case 4:\n            _yield$_awaitAsyncGen = _context.sent;\n            value = _yield$_awaitAsyncGen.value;\n            done = _yield$_awaitAsyncGen.done;\n            if (!done) {\n              _context.next = 19;\n              break;\n            }\n            if (currentMessageTotalLength) {\n              _context.next = 12;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 12:\n            if (!(currentMessageTotalLength === currentMessagePendingLength)) {\n              _context.next = 17;\n              break;\n            }\n            _context.next = 15;\n            return currentMessage;\n          case 15:\n            _context.next = 18;\n            break;\n          case 17:\n            throw new Error(\"Truncated event message received.\");\n          case 18:\n            return _context.abrupt(\"return\");\n          case 19:\n            chunkLength = value.length;\n            currentOffset = 0;\n          case 21:\n            if (!(currentOffset < chunkLength)) {\n              _context.next = 45;\n              break;\n            }\n            if (currentMessage) {\n              _context.next = 33;\n              break;\n            }\n            bytesRemaining = chunkLength - currentOffset;\n            if (!messageLengthBuffer) {\n              messageLengthBuffer = new Uint8Array(4);\n            }\n            numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);\n            messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesForTotal;\n            currentOffset += numBytesForTotal;\n            if (!(currentMessagePendingLength < 4)) {\n              _context.next = 31;\n              break;\n            }\n            return _context.abrupt(\"break\", 45);\n          case 31:\n            allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n            messageLengthBuffer = null;\n          case 33:\n            numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);\n            currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesToWrite;\n            currentOffset += numBytesToWrite;\n            if (!(currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength)) {\n              _context.next = 43;\n              break;\n            }\n            _context.next = 40;\n            return currentMessage;\n          case 40:\n            currentMessage = null;\n            currentMessageTotalLength = 0;\n            currentMessagePendingLength = 0;\n          case 43:\n            _context.next = 21;\n            break;\n          case 45:\n            _context.next = 1;\n            break;\n          case 47:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function iterator() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return _defineProperty({}, Symbol.asyncIterator, iterator);\n}","map":{"version":3,"names":["getChunkedStream","source","currentMessageTotalLength","currentMessagePendingLength","currentMessage","messageLengthBuffer","allocateMessage","size","Error","Uint8Array","currentMessageView","DataView","buffer","setUint32","iterator","_ref","_wrapAsyncGenerator","_regeneratorRuntime","mark","_callee","sourceIterator","_yield$_awaitAsyncGen","value","done","chunkLength","currentOffset","bytesRemaining","numBytesForTotal","numBytesToWrite","wrap","_callee$","_context","prev","next","Symbol","asyncIterator","_awaitAsyncGenerator","sent","abrupt","length","Math","min","set","slice","getUint32","stop","apply","arguments","_defineProperty"],"sources":["/Users/ericli/Desktop/pill2/node_modules/@aws-sdk/client-s3/node_modules/@aws-sdk/eventstream-serde-universal/dist-es/getChunkedStream.js"],"sourcesContent":["export function getChunkedStream(source) {\n    let currentMessageTotalLength = 0;\n    let currentMessagePendingLength = 0;\n    let currentMessage = null;\n    let messageLengthBuffer = null;\n    const allocateMessage = (size) => {\n        if (typeof size !== \"number\") {\n            throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n        }\n        currentMessageTotalLength = size;\n        currentMessagePendingLength = 4;\n        currentMessage = new Uint8Array(size);\n        const currentMessageView = new DataView(currentMessage.buffer);\n        currentMessageView.setUint32(0, size, false);\n    };\n    const iterator = async function* () {\n        const sourceIterator = source[Symbol.asyncIterator]();\n        while (true) {\n            const { value, done } = await sourceIterator.next();\n            if (done) {\n                if (!currentMessageTotalLength) {\n                    return;\n                }\n                else if (currentMessageTotalLength === currentMessagePendingLength) {\n                    yield currentMessage;\n                }\n                else {\n                    throw new Error(\"Truncated event message received.\");\n                }\n                return;\n            }\n            const chunkLength = value.length;\n            let currentOffset = 0;\n            while (currentOffset < chunkLength) {\n                if (!currentMessage) {\n                    const bytesRemaining = chunkLength - currentOffset;\n                    if (!messageLengthBuffer) {\n                        messageLengthBuffer = new Uint8Array(4);\n                    }\n                    const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);\n                    messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n                    currentMessagePendingLength += numBytesForTotal;\n                    currentOffset += numBytesForTotal;\n                    if (currentMessagePendingLength < 4) {\n                        break;\n                    }\n                    allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n                    messageLengthBuffer = null;\n                }\n                const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);\n                currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n                currentMessagePendingLength += numBytesToWrite;\n                currentOffset += numBytesToWrite;\n                if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {\n                    yield currentMessage;\n                    currentMessage = null;\n                    currentMessageTotalLength = 0;\n                    currentMessagePendingLength = 0;\n                }\n            }\n        }\n    };\n    return {\n        [Symbol.asyncIterator]: iterator,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}