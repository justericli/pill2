{"ast":null,"code":"import { DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nexport var getDefaultRetryToken = function getDefaultRetryToken(initialRetryTokens, initialRetryDelay, initialRetryCount, options) {\n  var _options$retryCost, _options$timeoutRetry, _options$retryBackoff;\n  var MAX_CAPACITY = initialRetryTokens;\n  var retryCost = (_options$retryCost = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _options$retryCost !== void 0 ? _options$retryCost : RETRY_COST;\n  var timeoutRetryCost = (_options$timeoutRetry = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _options$timeoutRetry !== void 0 ? _options$timeoutRetry : TIMEOUT_RETRY_COST;\n  var retryBackoffStrategy = (_options$retryBackoff = options === null || options === void 0 ? void 0 : options.retryBackoffStrategy) !== null && _options$retryBackoff !== void 0 ? _options$retryBackoff : getDefaultRetryBackoffStrategy();\n  var availableCapacity = initialRetryTokens;\n  var retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);\n  var lastRetryCost = undefined;\n  var retryCount = initialRetryCount !== null && initialRetryCount !== void 0 ? initialRetryCount : 0;\n  var getCapacityAmount = function getCapacityAmount(errorType) {\n    return errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost;\n  };\n  var getRetryCount = function getRetryCount() {\n    return retryCount;\n  };\n  var getRetryDelay = function getRetryDelay() {\n    return retryDelay;\n  };\n  var getLastRetryCost = function getLastRetryCost() {\n    return lastRetryCost;\n  };\n  var hasRetryTokens = function hasRetryTokens(errorType) {\n    return getCapacityAmount(errorType) <= availableCapacity;\n  };\n  var getRetryTokenCount = function getRetryTokenCount(errorInfo) {\n    var errorType = errorInfo.errorType;\n    if (!hasRetryTokens(errorType)) {\n      throw new Error(\"No retry token available\");\n    }\n    var capacityAmount = getCapacityAmount(errorType);\n    var delayBase = errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;\n    retryBackoffStrategy.setDelayBase(delayBase);\n    var delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\n    if (errorInfo.retryAfterHint) {\n      var delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\n      retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\n    } else {\n      retryDelay = delayFromErrorType;\n    }\n    retryCount++;\n    lastRetryCost = capacityAmount;\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n  var releaseRetryTokens = function releaseRetryTokens(releaseAmount) {\n    availableCapacity += releaseAmount !== null && releaseAmount !== void 0 ? releaseAmount : NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n  return {\n    getRetryCount: getRetryCount,\n    getRetryDelay: getRetryDelay,\n    getLastRetryCost: getLastRetryCost,\n    hasRetryTokens: hasRetryTokens,\n    getRetryTokenCount: getRetryTokenCount,\n    releaseRetryTokens: releaseRetryTokens\n  };\n};","map":{"version":3,"names":["DEFAULT_RETRY_DELAY_BASE","MAXIMUM_RETRY_DELAY","NO_RETRY_INCREMENT","RETRY_COST","THROTTLING_RETRY_DELAY_BASE","TIMEOUT_RETRY_COST","getDefaultRetryBackoffStrategy","getDefaultRetryToken","initialRetryTokens","initialRetryDelay","initialRetryCount","options","_options$retryCost","_options$timeoutRetry","_options$retryBackoff","MAX_CAPACITY","retryCost","timeoutRetryCost","retryBackoffStrategy","availableCapacity","retryDelay","Math","min","lastRetryCost","undefined","retryCount","getCapacityAmount","errorType","getRetryCount","getRetryDelay","getLastRetryCost","hasRetryTokens","getRetryTokenCount","errorInfo","Error","capacityAmount","delayBase","setDelayBase","delayFromErrorType","computeNextBackoffDelay","retryAfterHint","delayFromRetryAfterHint","getTime","Date","now","max","releaseRetryTokens","releaseAmount"],"sources":["/Users/ericli/Desktop/pill2/node_modules/@aws-sdk/util-retry/dist-es/defaultRetryToken.js"],"sourcesContent":["import { DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST, } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nexport const getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {\n    const MAX_CAPACITY = initialRetryTokens;\n    const retryCost = options?.retryCost ?? RETRY_COST;\n    const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;\n    const retryBackoffStrategy = options?.retryBackoffStrategy ?? getDefaultRetryBackoffStrategy();\n    let availableCapacity = initialRetryTokens;\n    let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);\n    let lastRetryCost = undefined;\n    let retryCount = initialRetryCount ?? 0;\n    const getCapacityAmount = (errorType) => (errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost);\n    const getRetryCount = () => retryCount;\n    const getRetryDelay = () => retryDelay;\n    const getLastRetryCost = () => lastRetryCost;\n    const hasRetryTokens = (errorType) => getCapacityAmount(errorType) <= availableCapacity;\n    const getRetryTokenCount = (errorInfo) => {\n        const errorType = errorInfo.errorType;\n        if (!hasRetryTokens(errorType)) {\n            throw new Error(\"No retry token available\");\n        }\n        const capacityAmount = getCapacityAmount(errorType);\n        const delayBase = errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;\n        retryBackoffStrategy.setDelayBase(delayBase);\n        const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\n        if (errorInfo.retryAfterHint) {\n            const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\n            retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\n        }\n        else {\n            retryDelay = delayFromErrorType;\n        }\n        retryCount++;\n        lastRetryCost = capacityAmount;\n        availableCapacity -= capacityAmount;\n        return capacityAmount;\n    };\n    const releaseRetryTokens = (releaseAmount) => {\n        availableCapacity += releaseAmount ?? NO_RETRY_INCREMENT;\n        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n    };\n    return {\n        getRetryCount,\n        getRetryDelay,\n        getLastRetryCost,\n        hasRetryTokens,\n        getRetryTokenCount,\n        releaseRetryTokens,\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}